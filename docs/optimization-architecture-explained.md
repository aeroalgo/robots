# Архитектура оптимизации стратегий

## Обзор

В системе реализованы **два варианта** оптимизации стратегий:

1. **Вариант 1: Гибридная оптимизация** (один GA для всех структур)
   - Используется в `examples/genetic_optimization.rs`
   - Один генетический алгоритм оптимизирует параметры для всех структур одновременно
   - Быстрее, но менее точная оптимизация для каждой структуры

2. **Вариант 2: Оптимизация по структурам** (отдельный GA для каждой структуры)
   - Используется в `examples/per_structure_optimization.rs`
   - Для каждой структуры запускается отдельный генетический алгоритм
   - Медленнее, но более точная оптимизация для каждой структуры
   - Фильтрация по порогам после оптимизации
   - Сохранение в БД

---

## Общие компоненты

### 1. Discovery Layer (Генерация структур стратегий)

**Что делает:**
- Генерирует **структуры стратегий** (StrategyCandidate) через ленивый итератор
- **НЕ оптимизирует параметры** - только создает структуру

**Структура стратегии включает:**
- Какие индикаторы используются (SMA, EMA, RSI и т.д.)
- Какие условия входа/выхода
- Какие стоп-обработчики
- Какие таймфреймы

**Ленивая генерация:**
```rust
StrategyIterator::next() -> Option<StrategyCandidate>
```
- Генерирует стратегии по требованию
- Не держит все в памяти
- Каждый вызов `next()` возвращает новую структуру стратегии

**Конфигурация:**
- `max_optimization_params` - максимальное количество оптимизируемых параметров
- `timeframe_count` - количество таймфреймов
- `allow_indicator_on_indicator` - разрешить индикаторы на индикаторах
- `max_indicator_depth` - максимальная глубина вложенности

---

## Вариант 1: Гибридная оптимизация

### Описание

Один генетический алгоритм оптимизирует параметры для **всех структур стратегий одновременно**. Структуры стратегий не меняются в процессе эволюции, меняются только параметры.

### Компоненты

#### 1.1 Initial Population Generator (V1 - с дефолтными параметрами)

**Файл:** `src/optimization/initial_population.rs`

**Что делает:**
- Берет структуры стратегий из Discovery
- Для каждой структуры:
  1. Извлекает **параметры по умолчанию** (из диапазонов оптимизации)
  2. Выполняет backtest с этими параметрами
  3. **Проверяет пороги** (fitness thresholds)
  4. Если проходит - добавляет в популяцию

**Важно:** 
- На этом этапе каждая стратегия тестируется **только с параметрами по умолчанию**
- Пороги проверяются **до** добавления в популяцию
- Только прошедшие пороги стратегии попадают в начальную популяцию

#### 1.2 Initial Population Generator (V2 - с рандомными параметрами)

**Файл:** `src/optimization/initial_population_v2.rs`

**Что делает:**
- Берет структуры стратегий из Discovery
- Для каждой структуры:
  1. Генерирует **рандомные параметры** (из диапазонов оптимизации)
  2. Выполняет backtest с этими параметрами
  3. **НЕ проверяет пороги** на этом этапе
  4. Добавляет в популяцию (все стратегии, независимо от fitness)

**Важно:**
- Параметры генерируются **рандомно**, не дефолтные
- Пороги **НЕ проверяются** на этапе инициализации
- Пороги проверяются только **после завершения оптимизации**
- После генерации всех начальных популяций применяется **Fresh Blood** для добавления разнообразия

#### 1.3 Genetic Algorithm

**Файлы:** 
- `src/optimization/genetic.rs` (для V1)
- `src/optimization/genetic_v2.rs` (для V2)

**Что делает:**
- Берет популяцию стратегий (уже с протестированными параметрами)
- В каждом поколении:
  1. **Селекция** - выбирает лучшие стратегии (по fitness)
  2. **Скрещивание** - комбинирует параметры от родителей
  3. **Мутация** - немного изменяет параметры
  4. **Оценка** - тестирует новые варианты параметров через backtest
  5. **Отбор** - сохраняет лучшие, удаляет слабые

**Важно:** 
- Генетический алгоритм оптимизирует параметры для **уже существующих структур стратегий**
- Он **не создает новые структуры** - структуры остаются неизменными
- В процессе эволюции меняются только параметры

#### 1.4 Island Management (Управление островами)

**Файл:** `src/optimization/island.rs`

**Что делает:**
- Создает несколько изолированных популяций (островов)
- Каждый остров эволюционирует независимо
- Периодически происходит миграция между островами

**Преимущества:**
- Предотвращает преждевременную сходимость
- Увеличивает разнообразие популяции
- Параллельная эволюция

#### 1.5 Fresh Blood System

**Файл:** `src/optimization/fresh_blood.rs`

**Что делает:**
- Периодически добавляет новые стратегии в популяцию
- Заменяет дубликаты или слабые стратегии
- Поддерживает разнообразие популяции

**Когда применяется:**
- После генерации начальных популяций (для V2)
- Периодически во время эволюции

### Процесс работы (Вариант 1)

```
┌─────────────────────────────────────────────────────────┐
│ 1. Discovery Layer                                      │
│    StrategyIterator::next()                             │
│    └─> StrategyCandidate { структура }                 │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 2. Initial Population Generator                         │
│    Для каждой структуры:                                │
│    ├─> V1: Параметры по умолчанию + проверка порогов   │
│    └─> V2: Рандомные параметры (без проверки порогов)  │
│    └─> Backtest                                         │
│    └─> Если проходит (V1) или всегда (V2) →            │
│        GeneticIndividual { candidate, parameters, ... } │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 3. Fresh Blood (только для V2)                          │
│    После генерации всех начальных популяций             │
│    └─> Инъекция новых стратегий для разнообразия       │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 4. Island Management                                    │
│    Создание нескольких островов                         │
│    └─> Каждый остров = отдельная популяция             │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 5. Genetic Algorithm (один для всех структур)           │
│    Поколение 1:                                         │
│    ├─> Селекция лучших                                  │
│    ├─> Скрещивание параметров                          │
│    ├─> Мутация параметров                               │
│    └─> Тестирование новых параметров                   │
│                                                          │
│    Поколение 2:                                         │
│    ├─> (то же самое, но параметры улучшаются)          │
│    └─> ...                                              │
│                                                          │
│    Поколение N:                                         │
│    └─> Лучшие параметры для всех структур              │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 6. Результат                                            │
│    Лучшие стратегии с оптимизированными параметрами    │
│    (структуры остались теми же, параметры оптимизированы)│
└─────────────────────────────────────────────────────────┘
```

### Пример использования (Вариант 1)

**V1 (с дефолтными параметрами):**
```bash
cargo run --example genetic_optimization
```

**V2 (с рандомными параметрами):**
```bash
cargo run --example genetic_optimization_v2
```

### Преимущества Варианта 1

- ✅ Быстрее - один GA для всех структур
- ✅ Меньше вычислений
- ✅ Хорошо работает для большого количества структур
- ✅ Эффективное использование ресурсов

### Недостатки Варианта 1

- ❌ Менее точная оптимизация для каждой структуры
- ❌ Параметры оптимизируются для всех структур одновременно
- ❌ Может пропустить хорошие комбинации структура+параметры

---

## Вариант 2: Оптимизация по структурам

### Описание

Для **каждой структуры стратегии** запускается **отдельный генетический алгоритм** оптимизации параметров. После оптимизации каждой структуры применяется фильтрация по порогам, и отфильтрованные стратегии сохраняются в БД.

### Компоненты

#### 2.1 PerStructureOptimizer

**Файл:** `src/optimization/per_structure_optimizer.rs`

**Что делает:**
- Принимает структуру стратегии (StrategyCandidate)
- Создает начальную популяцию с рандомными параметрами для этой структуры
- Запускает отдельный генетический алгоритм оптимизации
- Возвращает все результаты оптимизации для этой структуры

**Процесс:**
1. Генерация начальной популяции с рандомными параметрами
2. Эволюция на N поколений (оптимизация параметров)
3. Возврат всех результатов оптимизации

#### 2.2 Фильтрация по порогам

**Что делает:**
- После оптимизации каждой структуры применяется фильтрация
- Проверяются пороги (FitnessThresholds):
  - `min_profit_factor` - минимальный Profit Factor (например, >= 1.5)
  - `min_sharpe_ratio` - минимальный Sharpe Ratio
  - `min_win_rate` - минимальный процент выигрышных сделок
  - `min_total_profit` - минимальная общая прибыль
  - `min_trades_count` - минимальное количество сделок
  - И другие пороги

**Важно:**
- Пороги проверяются **только после завершения оптимизации**
- Каждая структура фильтруется независимо
- Нет сравнения между стратегиями - каждая структура обрабатывается отдельно

#### 2.3 StrategySaver

**Файл:** `src/optimization/strategy_saver.rs`

**Что делает:**
- Конвертирует оптимизированные стратегии в `StrategyDefinition`
- Форматирует данные для отображения
- Сериализует стратегии в JSON для сохранения в БД

**Методы:**
- `convert_to_definition()` - конвертация в StrategyDefinition
- `format_for_storage()` - форматирование для отображения
- `serialize_for_db()` - сериализация в JSON для БД

### Процесс работы (Вариант 2)

```
┌─────────────────────────────────────────────────────────┐
│ 1. Discovery Layer                                      │
│    Генерация структур стратегий (лениво)               │
│    └─> StrategyCandidate 1, 2, 3, ... N                │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 2. Для каждой структуры стратегии:                      │
│                                                          │
│    ┌──────────────────────────────────────────────┐    │
│    │ Структура 1:                                  │    │
│    │ ┌──────────────────────────────────────────┐ │    │
│    │ │ 2.1. Initial Population Generator V2     │ │    │
│    │ │    Генерация рандомных параметров        │ │    │
│    │ │    └─> Популяция из 20 стратегий         │ │    │
│    │ └──────────────────────────────────────────┘ │    │
│    │              ↓                                │    │
│    │ ┌──────────────────────────────────────────┐ │    │
│    │ │ 2.2. Genetic Algorithm V2                │ │    │
│    │ │    Поколение 1:                          │ │    │
│    │ │    ├─> Селекция                          │ │    │
│    │ │    ├─> Скрещивание                       │ │    │
│    │ │    ├─> Мутация                           │ │    │
│    │ │    └─> Оценка                            │ │    │
│    │ │    ...                                   │ │    │
│    │ │    Поколение 10:                         │ │    │
│    │ │    └─> Оптимизированные параметры        │ │    │
│    │ └──────────────────────────────────────────┘ │    │
│    │              ↓                                │    │
│    │ ┌──────────────────────────────────────────┐ │    │
│    │ │ 2.3. Фильтрация по порогам               │ │    │
│    │ │    Проверка:                             │ │    │
│    │ │    ├─> Profit Factor >= 1.5?             │ │    │
│    │ │    ├─> Sharpe Ratio >= 0.5?              │ │    │
│    │ │    ├─> Win Rate >= 40%?                  │ │    │
│    │ │    └─> ...                               │ │    │
│    │ │    └─> Результаты, прошедшие пороги      │ │    │
│    │ └──────────────────────────────────────────┘ │    │
│    │              ↓                                │    │
│    │ ┌──────────────────────────────────────────┐ │    │
│    │ │ 2.4. Сохранение в БД                     │ │    │
│    │ │    Сериализация в JSON                   │ │    │
│    │ │    └─> Запись в базу данных              │ │    │
│    │ └──────────────────────────────────────────┘ │    │
│    └──────────────────────────────────────────────┘    │
│                                                          │
│    ┌──────────────────────────────────────────────┐    │
│    │ Структура 2:                                  │    │
│    │ (тот же процесс)                              │    │
│    └──────────────────────────────────────────────┘    │
│                                                          │
│    ...                                                   │
│                                                          │
│    ┌──────────────────────────────────────────────┐    │
│    │ Структура N:                                  │    │
│    │ (тот же процесс)                              │    │
│    └──────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 3. Итоговый результат                                   │
│    Все стратегии, прошедшие пороги, сохранены в БД     │
│    (каждая структура обработана независимо)            │
└─────────────────────────────────────────────────────────┘
```

### Пример использования (Вариант 2)

```bash
cargo run --example per_structure_optimization
```

### Конфигурация порогов (Вариант 2)

```rust
fitness_thresholds: FitnessThresholds {
    min_profit_factor: Some(1.5),      // Profit Factor >= 1.5
    min_sharpe_ratio: Some(0.5),       // Sharpe Ratio >= 0.5
    min_win_rate: Some(0.40),          // Win Rate >= 40%
    min_total_profit: Some(500.0),     // Total Profit >= 500
    min_trades_count: Some(20),        // Min Trades >= 20
    min_cagr: Some(5.0),               // CAGR >= 5%
    max_drawdown_pct: Some(30.0),      // Max Drawdown <= 30%
    max_max_drawdown: Some(10000.0),   // Max Drawdown <= 10000
}
```

### Преимущества Варианта 2

- ✅ Более точная оптимизация для каждой структуры
- ✅ Каждая структура получает полную оптимизацию параметров
- ✅ Независимая обработка структур
- ✅ Фильтрация по порогам после оптимизации
- ✅ Автоматическое сохранение в БД
- ✅ Нет сравнения между стратегиями - каждая структура оценивается независимо

### Недостатки Варианта 2

- ❌ Медленнее - отдельный GA для каждой структуры
- ❌ Больше вычислений
- ❌ Требует больше времени для большого количества структур

---

## Сравнение вариантов

| Характеристика | Вариант 1: Гибридная | Вариант 2: По структурам |
|----------------|---------------------|-------------------------|
| **Количество GA** | 1 для всех структур | 1 для каждой структуры |
| **Скорость** | Быстрее | Медленнее |
| **Точность** | Менее точная | Более точная |
| **Проверка порогов** | До/после (зависит от V1/V2) | Только после оптимизации |
| **Сравнение стратегий** | Да (по fitness) | Нет (независимая обработка) |
| **Сохранение в БД** | Нет (в примере) | Да (автоматическое) |
| **Использование** | Быстрый поиск хороших стратегий | Точная оптимизация и сохранение |

---

## Когда использовать какой вариант?

### Используйте Вариант 1, если:
- Нужно быстро найти хорошие стратегии
- Есть много структур для проверки
- Ограничены вычислительные ресурсы
- Нужен общий обзор возможных стратегий

### Используйте Вариант 2, если:
- Нужна точная оптимизация для каждой структуры
- Важна независимая оценка каждой структуры
- Нужно сохранить результаты в БД
- Есть время для полной оптимизации
- Важна фильтрация по строгим порогам

---

## Вывод

**В системе реализованы два подхода:**

1. **Вариант 1 (Гибридная оптимизация):**
   - Один GA оптимизирует параметры для всех структур одновременно
   - Быстрее, но менее точная оптимизация
   - Подходит для быстрого поиска стратегий

2. **Вариант 2 (Оптимизация по структурам):**
   - Отдельный GA для каждой структуры
   - Медленнее, но более точная оптимизация
   - Фильтрация по порогам и сохранение в БД
   - Подходит для точной оптимизации и сохранения результатов

**Оба варианта используют:**
- Discovery Layer для генерации структур стратегий
- Genetic Algorithm для оптимизации параметров
- Backtest для оценки стратегий
- Fitness Function для расчета пригодности

**Разница в подходе:**
- Вариант 1: оптимизация параметров для всех структур одновременно
- Вариант 2: оптимизация параметров для каждой структуры отдельно

