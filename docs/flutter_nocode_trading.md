## Конструктор торговых роботов в стиле no-code

Этот документ описывает несколько подходов к созданию конструктора торговых роботов, напоминающего TSLab, но доступного в вебе или мобильных приложениях на Flutter. Рассматриваем решения, ориентированные на no-code или low-code сценарии, позволяющие пользователю собирать стратегии из блоков, указывать формулы и комбинировать условия.

---

## Вариант 1. Flutter + визуальный блоковый редактор (пример: интеграция с FlutterFlow Graph Editor или custom Blockly)

- **Идея**: встраиваем в Flutter приложение визуальную среду на основе Blockly или аналогичного редактора, где каждый блок представляет действие: получение котировок, вычисление индикатора, установка условий, отправка заявок.
- **Как работает**:
  - Пользователь перетаскивает блоки «Источник данных», «Индикатор», «Условие», «Действие» и соединяет их.
  - Каждому блоку соответствует JSON-конфигурация; далее бэкенд интерпретирует конфигурацию и исполняет стратегию.
  - Для формул можно добавить текстовый блок на языке выражений: `EMA(close, 20) > EMA(close, 50)` и т.д.
- **Пример сценария**:
  - Блок «Загрузка данных» → Блок «Индикатор RSI» → Блок «Условие RSI < 30» → Блок «Покупка» → Блок «Установка стоп-лосса».
  - Пользователь меняет параметры индикаторов прямо в блоках, включая периоды и используемые поля.
- **Плюсы**:
  - Максимальная наглядность, подходит для новичков.
  - Простая сериализация в JSON/GraphQL для хранения стратегий.
  - Flutter может рендерить блоки через webview или нативно (например, через flutter_blockly).
- **Минусы**:
  - Требует проработки визуальной библиотеки блоков и логики связей.
  - Сложно поддерживать расширяемость без продуманной архитектуры блоков (типизация входов/выходов, проверки ошибок).

---

## Вариант 2. Flutter + DSL-конструктор (формулы и условия в псевдокоде)

- **Идея**: предоставляем пользователю конструктор формул, похожий на Excel или Pine Script, но в ограниченном синтаксисе. Интерфейс напоминает NoCode-редакторы формул (например, в Airtable), с автодополнением и подсказками.
- **Как работает**:
  - Пользователь создаёт шаги стратегии: «Расчёт индикатора», «Условие входа», «Действие при выполнении».
  - Каждый шаг содержит выражение на DSL: `if crossOver(EMA(close, 20), EMA(close, 50)) then BUY qty=10`.
  - UI предоставляет список доступных функций, автогенерацию шаблонов, проверку синтаксиса на лету.
  - Код DSL транслируется на бэкенде в Python/Rust/TS для исполнения.
- **Пример сценария**:
  - Ввод формулы: `signal = SMA(close, 14) - SMA(close, 28)`; затем `if signal > 0 and volume > avgVolume(20) then BUY`.
- **Плюсы**:
  - Гибкость: проще описать сложные формулы, чем в блоках.
  - Простая сериализация стратегий в текстовом виде.
  - Легко версионировать и делиться стратегиями.
- **Минусы**:
  - Порог входа выше, чем у чисто визуальных редакторов.
  - Нужно обеспечить ясные подсказки и отладку формул.

---

## Вариант 3. Flutter + диаграммы состояний (Node-RED / BPMN-подход)

- **Идея**: использовать граф состояний и переходов, где узлы — логические блоки стратегии, а рёбра — условия перехода. Можно адаптировать open-source решения вроде Node-RED, BPMN, Camunda через webview или REST-API.
- **Как работает**:
  - Пользователь собирает из «узлов» (события, обработчики, действия) диаграмму.
  - Например: узел «Получить тик» → условие «Цена > SMA50» → узел «Отправить заявку» → узел «Ожидать исполнения» → узел «Выставить стоп».
  - Каждый переход содержит условие, которое описывается формулой или выбором преднастроенных правил.
  - Система сериализует диаграмму в XML/JSON BPMN и выполняет её через движок.
- **Пример сценария**:
  - Диаграмма, где параллельные ветви отвечают за вход и выход из позиции, а общий узел агрегирует сигналы разных индикаторов.
- **Плюсы**:
  - Подходит для сложных стратегий с ветвлениями, управлением состояниями, длительными процессами.
  - Имеет визуальную интерпретируемость, удобно поддерживать.
- **Минусы**:
  - Сложнее для пользователей без опыта работы с BPMN/диаграммами.
  - Требует интеграции со сторонним движком или реализации собственного интерпретатора.

---

## Вариант 4. Flutter + конструктор с библиотекой шаблонов (Template Builder)

- **Идея**: комбинируем визуальные блоки с готовыми шаблонами стратегий. Пользователь выбирает базовый шаблон (трендовая, контртрендовая, арбитражная), затем настраивает параметры и добавляет свои условия.
- **Как работает**:
  - Каталог шаблонов в UI: «EMA Crossover», «RSI Divergence», «Bollinger Bounce».
  - После выбора шаблона открывается редактор: блоки и параметры предварительно заполнены.
  - Пользователь может добавлять/удалять узлы, подключать дополнительные правила (например, фильтр по объёму).
  - Интерфейс отображает ожидаемую структуру стратегии и позволяет переключаться между визуальным и табличным видом.
- **Пример сценария**:
  - Шаблон «EMA Crossover» с блоками: `EMA Fast`, `EMA Slow`, `Entry`, `Exit`. Пользователь добавляет блок `ATR Trailing Stop` и выставляет порог `3 * ATR`.
- **Плюсы**:
  - Быстрый старт для начинающих, опора на проверенные стратегии.
  - Гибкость за счёт редактирования шаблона.
  - Можно монетизировать через библиотеку премиальных шаблонов.
- **Минусы**:
  - Ограниченность, если пользователь хочет уникальные структуры вне шаблонов.
  - Необходимость поддерживать и обновлять шаблонную базу.

---

## Вариант 5. Flutter + интеграция с формульными таблицами (например, Polars/Pandas в облаке)

- **Идея**: предоставить интерфейс, похожий на Google Sheets/Excel, но с ориентацией на финансовые данные. Каждая строка — торговый шаг, столбцы — условия/действия, формулы задаются через табличный редактор.
- **Как работает**:
  - Пользователь создаёт таблицу с колонками `Condition`, `Action`, `Parameters`.
  - Формулы в ячейках: `=IF(EMA_CLOSE_20 > EMA_CLOSE_50; "BUY"; "")`.
  - На бэкенде формулы интерпретируются и исполняются; результаты симуляций отображаются в графиках прямо в приложении.
  - Можно подключать внешние источники данных через API, выгружать отчёты.
- **Пример сценария**:
  - Столбец `EntryRule`: `=AND(RSI(14) < 30; Volume > SMA(Volume, 20))` → `BUY`.
  - Столбец `ExitRule`: `=OR(RSI(14) > 60; Price < StopLoss)`.
- **Плюсы**:
  - Пользователям, знакомым с таблицами, легко адаптироваться.
  - Повышенная гибкость благодаря формульному подходу.
  - Можно реализовать совместную работу и версионирование стратегий.
- **Минусы**:
  - Сложность визуального представления потоков и зависимостей.
  - Не так наглядно, как блок-схемы.

---

## Вариант 6. Flutter + сценарии на естественном языке (NL-to-Code)

- **Идея**: пользователь описывает стратегию на естественном языке, модель переводит описание в блоки или DSL. Это может быть гибрид: сначала AI предлагает проект, затем пользователь корректирует его в визуальном редакторе.
- **Как работает**:
  - Пользователь вводит: «Купи, когда EMA 20 пересекает EMA 50 снизу вверх и RSI ниже 30, продай при обратном пересечении или при достижении тейк-профита 5%».
  - Сервис преобразует текст в структуру блоков или DSL и отображает результат в UI для проверки.
  - Пользователь при необходимости правит результат вручную.
- **Пример сценария**:
  - Задача «построй стратегию свинг-трейдинга» → генерация блока источника данных, индикаторов, условий, действий, затем ручная настройка параметров.
- **Плюсы**:
  - Быстрый старт для пользователей без технических навыков.
  - Можно комбинировать с любым из предыдущих вариантов.
- **Минусы**:
  - Зависимость от качества модели.
  - Требуется интерфейс для валидации и корректировки стратегии.

---

## Рекомендации по реализации

- **Выбор архитектуры**:
  - Для мобильных и настольных клиентов на Flutter стоит отделить визуальный редактор (front) и исполнитель (back). Хороший кандидат — микросервис на Rust/Python для симуляций и торговли.
  - Графические элементы (блоки, диаграммы) можно хранить как JSON-схемы; формулы — как DSL-скрипты.
- **Бэкенд**:
  - Предоставить REST/GraphQL API для CRUD стратегий, запуска симуляций, получения исторических данных.
  - Использовать очереди и вебхуки для реальных сделок.
- **Хранилище**:
  - Сохранять версии стратегий, историю тестов, параметры запуска.
  - Реализовать библиотеку компонентов и шаблонов для повторного использования.
- **UI/UX**:
  - Поддержать drag-and-drop, undo/redo, подсветку синтаксиса, тестирование на примерах.
  - Добавить предпросмотр работы стратегии: графики доходности, список сделок, тепловые карты.
- **Безопасность и ограничения**:
  - Встроить проверку на потенциально опасные действия (например, торги с большим плечом).
  - Предусмотреть «песочницу» для тестирования стратегий до запуска на реальном счёте.

---

## Итоги

- Комбинация визуальных блоков и DSL даёт наиболее гибкую и понятную систему.
- Flutter позволяет создать кроссплатформенный клиент с богатыми UI-компонентами, а готовые решения (Blockly, Node-RED, BPMN) ускоряют разработку.
- Главные вызовы: продуманная модель данных стратегий, надёжный исполнитель, удобство проверки и отладки.
- Для MVP можно стартовать с варианта 1 или 4, расширив проект формульным редактором и AI-помощником на следующих этапах.


