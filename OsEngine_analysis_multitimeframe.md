# Анализ использования нескольких таймфреймов и синхронизации сигналов в OsEngine

## Обзор архитектуры

OsEngine использует архитектуру на основе событий (event-driven) для работы с несколькими таймфреймами. Основные компоненты:

### 1. CandleManager - центральный менеджер свечей

**Расположение:** `OsEngine/Candles/CandleManager.cs`

**Основные функции:**
- Управляет несколькими сериями свечей (`CandleSeries`) для разных таймфреймов
- Хранит активные серии в двух списках:
  - `_activeSeriesBasedOnTrades` - серии на основе тиков
  - `_activeSeriesBasedOnMd` - серии на основе стакана
- Синхронизирует обновления времени для всех активных серий через событие `TimeServerChangeEvent`

**Ключевые методы:**
```csharp
// Получение серии свечей по таймфрейму и инструменту
public CandleSeries GetSeries(TimeFrameBuilder timeFrameBuilder, Security security)

// Запуск новой серии
public void StartSeries(CandleSeries series)

// Обработка нового тика - распределение по всем подходящим сериям
private void server_NewTradeEvent(List<Trade> trades)
```

**Синхронизация времени:**
```csharp
private void _server_TimeServerChangeEvent(DateTime dateTime)
{
    // Обновляет время для всех активных серий
    for (int i = 0; _activeSeriesBasedOnTrades != null && i < _activeSeriesBasedOnTrades.Count; i++)
    {
        _activeSeriesBasedOnTrades[i].SetNewTime(dateTime);
    }
    // Аналогично для серий на основе стакана
}
```

### 2. CandleSeries - серия свечей для одного таймфрейма

**Расположение:** `OsEngine/Candles/CandleSeries.cs`

**Основные характеристики:**
- Каждая серия привязана к одному таймфрейму (`TimeFrameBuilder`)
- Хранит все свечи в `CandlesAll`
- Генерирует события:
  - `CandleUpdateEvent` - при обновлении текущей свечи
  - `CandleFinishedEvent` - при закрытии свечи

**Синхронизация данных:**
- При получении нового тика (`SetNewTicks`) проверяет, в какую свечу он попадает
- Обновляет только текущую незавершенную свечу
- При закрытии свечи генерирует событие `CandleFinishedEvent`

### 3. BotTabSimple - торговая вкладка

**Расположение:** `OsEngine/OsTrader/Panels/Tab/BotTabSimple.cs`

**Особенности:**
- Каждая вкладка может иметь свой таймфрейм
- Подписывается на события свечей через `ConnectorCandles`:
  - `NewCandlesChangeEvent` → `LogicToEndCandle` (завершение свечи)
  - `LastCandlesChangeEvent` → `LogicToUpdateLastCandle` (обновление текущей свечи)
- Генерирует события для стратегий:
  - `CandleFinishedEvent` - когда свеча закрылась
  - `CandleUpdateEvent` - при обновлении текущей свечи

## Пример использования нескольких таймфреймов: TwoTimeFramesBot

**Расположение:** `OsEngine/Robots/Trend/TwoTimeFramesBot.cs`

### Архитектура стратегии:

```csharp
private BotTabSimple _tabToTrade;  // Торговый таймфрейм (меньший)
private BotTabSimple _tabBigTf;    // Большой таймфрейм для фильтрации

// Индикаторы на разных таймфреймах
private Aindicator _pc;   // PriceChannel на торговом таймфрейме
private Aindicator _sma;  // SMA на большом таймфрейме
```

### Механизм синхронизации:

1. **Подписка на события:**
```csharp
// Подписываемся только на завершение свечей торгового таймфрейма
_tabToTrade.CandleFinishedEvent += _tabToTrade_CandleFinishedEvent;
```

2. **Логика принятия решений:**
```csharp
private void _tabToTrade_CandleFinishedEvent(List<Candle> candles)
{
    // Получаем данные с торгового таймфрейма
    decimal lastPriceOnTradeTab = candles[candles.Count - 1].Close;
    decimal lastPcUp = _pc.DataSeries[0].Values[_pc.DataSeries[0].Values.Count - 2];
    
    // Получаем данные с большого таймфрейма
    decimal lastPriceOnBigTfTab = _tabBigTf.CandlesAll[_tabBigTf.CandlesAll.Count - 1].Close;
    decimal lastSmaOnBigTfTab = _sma.DataSeries[0].Last;
    
    // Комбинируем условия с обоих таймфреймов
    if(lastPriceOnTradeTab > lastPcUp && lastPriceOnBigTfTab > lastSmaOnBigTfTab)
    {
        _tabToTrade.BuyAtMarket(GetVolume(_tabToTrade));
    }
}
```

### Ключевые особенности:

1. **Асинхронная синхронизация:**
   - Стратегия реагирует на завершение свечи торгового таймфрейма
   - При этом проверяет состояние большого таймфрейма (который обновляется реже)
   - Нет явной синхронизации по времени - используется последнее доступное значение

2. **Проверка готовности данных:**
```csharp
if(_tabBigTf.CandlesAll == null
    || _tabBigTf.CandlesAll.Count < 5 
    || candles.Count < 5)
{
    return; // Данные еще не готовы
}
```

3. **Использование индикаторов:**
   - Индикаторы создаются на конкретных табах (таймфреймах)
   - Каждый индикатор автоматически обновляется при обновлении своего таймфрейма
   - Стратегия читает последние значения индикаторов

## Механизм работы с несколькими таймфреймами

### 1. Создание нескольких табов

```csharp
// В конструкторе стратегии
TabCreate(BotTabType.Simple);  // Первый таб
TabCreate(BotTabType.Simple);  // Второй таб
_tabToTrade = TabsSimple[0];
_tabBigTf = TabsSimple[1];
```

### 2. Настройка таймфреймов

Каждый `BotTabSimple` имеет свой `TimeFrameBuilder`, который настраивается пользователем через UI или программно.

### 3. Синхронизация обновлений

**Проблема:** Разные таймфреймы обновляются с разной частотой:
- Младший таймфрейм (например, 1 минута) обновляется каждую минуту
- Старший таймфрейм (например, 1 час) обновляется каждый час

**Решение OsEngine:**
- Каждый таймфрейм генерирует события независимо
- Стратегия подписывается на события нужного таймфрейма (обычно младшего)
- При обработке события стратегия проверяет состояние других таймфреймов
- Используется последнее доступное значение старшего таймфрейма

### 4. Обработка индикаторов на разных таймфреймах

```csharp
// Индикатор на торговом таймфрейме
_pc = (Aindicator)_tabToTrade.CreateCandleIndicator(_pc, "Prime");

// Индикатор на большом таймфрейме
_sma = (Aindicator)_tabBigTf.CreateCandleIndicator(_sma, "Prime");
```

Каждый индикатор автоматически обновляется при обновлении своего таймфрейма.

## Синхронизация сигналов

### Подход OsEngine:

1. **Event-driven архитектура:**
   - Каждый таймфрейм генерирует события независимо
   - Стратегия решает, на какие события подписываться

2. **Явной синхронизации нет:**
   - Нет механизма ожидания обновления всех таймфреймов
   - Стратегия использует последние доступные значения

3. **Проверка готовности:**
   - Стратегия должна проверять, что данные с других таймфреймов доступны
   - Проверка количества свечей перед использованием

4. **Использование индексов:**
   - При чтении индикаторов используется индекс `Values.Count - 2` (предпоследнее значение)
   - Это связано с тем, что последняя свеча может быть еще не завершена

## Механизм расчета индикаторов

### Важное уточнение: НЕТ предрасчета, но ЕСТЬ инкрементальный расчет

**OsEngine НЕ использует предрасчет данных**, но использует **инкрементальный расчет по требованию**:

1. **Индикаторы рассчитываются при обновлении свечей:**
   - При закрытии свечи вызывается `CandleFinishedEvent`
   - Перед этим `_chartMaster.SetCandles(candles)` вызывает `Process()` для всех индикаторов
   - Индикаторы обновляют свои значения в `DataSeries`

2. **Инкрементальный расчет:**
   ```csharp
   public void Process(List<Candle> candles)
   {
       if (_myCandles.Count + 1 == candles.Count)
       {
           ProcessNew(candles, candles.Count - 1);  // Только новая свеча
       }
       else if (_myCandles.Count == candles.Count)
       {
           ProcessLast(candles);  // Обновление последней свечи
       }
       else
       {
           ProcessAll(candles);  // Полный пересчет
       }
   }
   ```

3. **В стратегии данные уже рассчитаны:**
   ```csharp
   // В момент вызова CandleFinishedEvent индикаторы уже обновлены
   decimal lastPcUp = _pc.DataSeries[0].Values[_pc.DataSeries[0].Values.Count - 2];
   decimal lastSmaOnBigTfTab = _sma.DataSeries[0].Last;
   ```

**Вывод:** Данные рассчитываются **по требованию** при обновлении свечей, но **не предрасчитываются заранее**. К моменту использования стратегией они уже готовы, так как расчет происходит в цепочке событий перед вызовом `CandleFinishedEvent`.

## Отличия от текущей реализации в Rust проекте

### Текущая реализация (Rust):
- Использует `MultiTimeFrameSignalSync` для явной синхронизации
- Отслеживает состояние сигналов на каждом таймфрейме
- Комбинирует сигналы с учетом иерархии таймфреймов
- Использует временные метки для проверки актуальности сигналов
- **Предрасчет индикаторов** в `populate_indicators()` перед началом бэктеста
- **Предрасчет условий** в `populate_conditions()` перед началом бэктеста

### OsEngine подход:
- Более простой и гибкий
- Стратегия сама решает, как комбинировать данные
- Нет явной синхронизации - используется последнее доступное значение
- Меньше накладных расходов, но требует больше внимания от разработчика стратегии
- **Инкрементальный расчет** индикаторов при каждом обновлении свечей
- **Нет предрасчета** - все рассчитывается по требованию в реальном времени

## Рекомендации для улучшения текущей реализации

1. **Добавить проверку готовности данных:**
   - Перед использованием данных с другого таймфрейма проверять их наличие
   - Проверять минимальное количество свечей

2. **Упростить синхронизацию:**
   - Можно сделать опциональную явную синхронизацию
   - По умолчанию использовать последние доступные значения

3. **Улучшить работу с индикаторами:**
   - Индикаторы должны автоматически обновляться при обновлении таймфрейма
   - Предоставить удобный доступ к последним значениям

4. **Добавить примеры стратегий:**
   - Показать, как правильно работать с несколькими таймфреймами
   - Демонстрировать различные паттерны комбинирования сигналов

