# Документация по генетической оптимизации стратегий

## Обзор

Генетическая оптимизация использует эволюционные алгоритмы для поиска оптимальных торговых стратегий. Система работает с двумя уровнями оптимизации:
1. **Структура стратегии** - индикаторы, условия входа/выхода, стоп-обработчики
2. **Параметры стратегии** - числовые значения параметров индикаторов, условий и стоп-обработчиков

## Архитектура

### Основные компоненты

- **GeneticAlgorithmV3** - основной класс генетического алгоритма
- **PopulationManager** - управление популяцией и генетическими операциями
- **StrategyEvaluationRunner** - оценка пригодности стратегий через бэктест
- **Population** - популяция особей (стратегий)
- **GeneticIndividual** - отдельная особь с оцененной стратегией

### Конфигурация

```rust
pub struct GeneticAlgorithmConfig {
    pub population_size: usize,           // Размер популяции (по умолчанию: 100)
    pub lambda_size: usize,               // Размер потомства (по умолчанию: 100)
    pub max_generations: usize,           // Максимальное количество поколений (по умолчанию: 50)
    pub crossover_rate: f64,              // Вероятность скрещивания (по умолчанию: 0.7)
    pub mutation_rate: f64,               // Вероятность мутации (по умолчанию: 0.1)
    pub elitism_count: usize,             // Количество элитных особей (по умолчанию: 5)
    pub param_mutation_min_percent: f64,  // Минимальный процент мутации параметра (по умолчанию: 0.03)
    pub param_mutation_max_percent: f64,  // Максимальный процент мутации параметра (по умолчанию: 0.05)
    // ... другие параметры
}
```

## Процесс эволюции одного поколения

### 1. Отбор элитных особей (Elitism)

**Функция**: `select_elites()`

**Процесс**:
1. Все особи сортируются по fitness (от лучшего к худшему)
2. Выбираются первые `elitism_count` особей
3. Эти особи автоматически переходят в следующее поколение без изменений

**Цель**: Сохранить лучшие решения и предотвратить деградацию популяции

### 2. Создание потомства (Offspring Generation)

**Функция**: `evolve_generation()`

**Процесс**:
1. Создается `lambda_size` новых особей
2. Для каждой пары родителей:
   - Выбираются 2 родителя через селекцию
   - Выполняется скрещивание структуры стратегии
   - Выполняется скрещивание параметров
   - Выполняется мутация структуры
   - Выполняется мутация параметров
   - Оценивается fitness новой особи

## Селекция родителей

**Функция**: `PopulationManager::select_parents()`

**Метод**: Пропорциональная селекция (Roulette Wheel Selection)

**Алгоритм**:
1. Вычисляется суммарный fitness всех особей: `total_fitness = Σ fitness_i`
2. Если `total_fitness == 0`, используется случайный отбор
3. Иначе:
   - Генерируется случайное число `r ∈ [0, total_fitness)`
   - Проходим по особям, суммируя их fitness
   - Когда накопленная сумма ≥ `r`, выбираем эту особь

**Особенности**:
- Особи с большим fitness имеют больше шансов быть выбранными
- Одна особь может быть выбрана несколько раз
- Если все особи имеют fitness = 0, используется равномерный случайный отбор

## Скрещивание (Crossover)

### Скрещивание структуры стратегии

**Функция**: `crossover_structure()`

**Вероятность**: `crossover_rate` (по умолчанию: 0.7)

**Процесс**:

#### Шаг 1: Скрещивание условий входа (Entry Conditions)

**Вероятность**: 50% (если скрещивание происходит)

**Алгоритм**:
1. Из родителя 2 извлекаются условия входа вместе с их индикаторами и таймфреймами
2. Эти условия добавляются к ребенку 1
3. Из родителя 1 извлекаются условия входа вместе с их индикаторами и таймфреймами
4. Эти условия добавляются к ребенку 2

**Функция извлечения**: `extract_conditions_with_indicators()`

**Что извлекается**:
- Условия входа (conditions) **всех типов**:
  - `indicator_price` (включая GreaterPercent/LowerPercent)
  - `indicator_constant` (для осцилляторов и volatility)
  - `indicator_indicator` (сравнение двух индикаторов)
  - `trend_condition` (RisingTrend/FallingTrend)
- Индикаторы, используемые в этих условиях
- Вложенные индикаторы (nested indicators)
- Таймфреймы из `primary_timeframe` и `secondary_timeframe` условий

**Валидация**:
- Условие переносится только если все его индикаторы существуют в родителе
- Индикаторы добавляются только если их еще нет в ребенке
- Таймфреймы добавляются только если их еще нет в ребенке
- **Все типы условий** переносятся одинаково, независимо от их типа

#### Шаг 2: Скрещивание условий выхода (Exit Conditions)

**Вероятность**: 50% (если скрещивание происходит)

**Алгоритм**: Аналогичен скрещиванию условий входа

#### Шаг 3: Очистка неиспользуемых элементов

**Функция**: `remove_unused_indicators()`

**Процесс**:
1. Определяются все используемые индикаторы (из условий входа и выхода)
2. Определяются все используемые таймфреймы (из условий)
3. Удаляются индикаторы, которые не используются ни в одном условии
4. Удаляются таймфреймы, которые не используются ни в одном условии

#### Шаг 4: Скрещивание стоп-обработчиков

**Вероятность**: 50% (если скрещивание происходит)

**Алгоритм**: Простое обмен местами (`std::mem::swap`) стоп-обработчиков между детьми

#### Шаг 5: Скрещивание тейк-обработчиков

**Вероятность**: 50% (если скрещивание происходит)

**Алгоритм**: Простое обмен местами тейк-обработчиков между детьми

#### Шаг 6: Скрещивание таймфреймов

**Вероятность**: 50% (если скрещивание происходит)

**Алгоритм**: Простое обмен местами списков таймфреймов между детьми

**Важно**: Таймфреймы также переносятся вместе с условиями на шаге 1-2, поэтому этот шаг является дополнительным.

### Скрещивание параметров

**Функция**: `PopulationManager::crossover()`

**Вероятность**: `crossover_rate` (по умолчанию: 0.7)

**Алгоритм**: Uniform Crossover (равномерное скрещивание)

**Процесс**:
1. Собираются все ключи параметров из обоих родителей
2. Для каждого ключа:
   - С вероятностью 50%:
     - Ребенок 1 получает значение от родителя 1
     - Ребенок 2 получает значение от родителя 2
   - С вероятностью 50%:
     - Ребенок 1 получает значение от родителя 2
     - Ребенок 2 получает значение от родителя 1

**Типы параметров, которые скрещиваются**:

1. **Параметры индикаторов**: `{indicator_name}_{param_name}`
   - Пример: `SMA_period`, `RSI_period`, `ATR_period`
   - Значения: `Number(f64)` или `Integer(i64)`

2. **Параметры вложенных индикаторов**: `nested_{indicator_name}_{param_name}`
   - Пример: `nested_EMA_period`
   - Значения: `Number(f64)` или `Integer(i64)`

3. **Параметры условий**: `condition_{condition_id}_{param_name}`
   - Пример: `condition_entry_sma1_threshold`
   - Значения: `Number(f64)` (пороговые значения, проценты)

4. **Параметры стоп-обработчиков**: `stop_{handler_name}_{param_name}`
   - Пример: `stop_StopLossPct_percentage`, `stop_ATRTrailStop_coeff_atr`
   - Значения: `Number(f64)`

5. **Параметры тейк-обработчиков**: Аналогично стоп-обработчикам

**Особенности**:
- Если параметр есть только у одного родителя, он копируется в обоих детей
- Если параметра нет ни у одного родителя, он не добавляется

## Мутация (Mutation)

### Мутация структуры стратегии

**Функция**: `mutate_structure()`

**Вероятность**: `mutation_rate` (по умолчанию: 0.1) для каждой операции

#### 1. Мутация индикаторов

**Вероятность**: `mutation_rate`

**Операции**:

**Удаление индикатора** (вероятность: 30% от `mutation_rate`):
1. Случайно выбирается индикатор из списка
2. Индикатор удаляется
3. Все условия, использующие этот индикатор, удаляются
4. Удаляются неиспользуемые индикаторы и таймфреймы

**Добавление индикатора** (вероятность: 70% от `mutation_rate`):
1. Случайно выбирается новый индикатор из доступных
2. Индикатор добавляется в стратегию
3. Автоматически создается новое условие входа с этим индикатором:
   - Случайно выбирается оператор (GreaterThan, LessThan, CrossesAbove, CrossesBelow)
   - Случайно выбирается поле цены (Close)
   - **В текущей реализации** всегда создается условие типа `"indicator_price"`

**⚠️ Ограничение текущей реализации**: При мутации создаются только простые условия типа `"indicator_price"`. Система поддерживает и другие типы условий (см. раздел "Типы условий"), но они не используются при мутации структуры. Это может быть улучшено в будущих версиях.

#### 2. Мутация условий входа

**Вероятность**: `mutation_rate`

**Операции**:

**Удаление условия** (вероятность: 30% от `mutation_rate`):
1. Случайно выбирается условие из списка
2. Условие удаляется
3. Удаляются неиспользуемые индикаторы и таймфреймы

**Добавление условия** (вероятность: 70% от `mutation_rate`):
1. Случайно выбирается индикатор из существующих в стратегии
2. Случайно выбирается оператор (GreaterThan, LessThan, CrossesAbove, CrossesBelow)
3. Случайно выбирается поле цены (Close)
4. **В текущей реализации** всегда создается условие типа `"indicator_price"`

**⚠️ Ограничение текущей реализации**: Аналогично мутации индикаторов, создаются только простые условия `"indicator_price"`.

#### 3. Мутация условий выхода

**Вероятность**: `mutation_rate`

**Операции**: Аналогичны мутации условий входа

**Ограничения**:
- Условие выхода можно удалить только если есть другие способы выхода (стоп-обработчики или тейк-обработчики)
- Или если есть другие условия выхода

#### 4. Мутация стоп-обработчиков

**Вероятность**: `mutation_rate`

**Операции**:

**Удаление стоп-обработчика** (вероятность: 30% от `mutation_rate`):
- Можно удалить только если есть другие способы выхода

**Добавление стоп-обработчика** (вероятность: 70% от `mutation_rate`):
- Случайно выбирается стоп-обработчик из доступных конфигураций
- Добавляется в стратегию

#### 5. Мутация тейк-обработчиков

**Вероятность**: `mutation_rate`

**Операции**: Аналогичны мутации стоп-обработчиков

**Ограничение**: Тейк-обработчик можно добавить только если есть условия выхода или стоп-обработчики

#### 6. Мутация таймфреймов

**Вероятность**: `mutation_rate * 0.5` (половина от обычной вероятности)

**Операции**:

**Удаление таймфрейма** (вероятность: 50%):
- Случайно выбирается таймфрейм и удаляется

**Добавление таймфрейма** (вероятность: 50%):
- Случайно выбирается таймфрейм из доступных (≥ базового таймфрейма)
- Добавляется в стратегию, если его еще нет

### Мутация параметров

**Функция**: `PopulationManager::mutate()`

**Вероятность**: `mutation_rate` для каждого параметра независимо

**Алгоритм**:

1. Для каждого параметра в стратегии:
   - С вероятностью `mutation_rate` параметр мутирует
   - Иначе параметр остается без изменений

2. Определение диапазона параметра:
   - Функция `get_parameter_range()` определяет допустимый диапазон для параметра
   - Используется информация о типе параметра (Period, Multiplier, Threshold, etc.)
   - Если диапазон не найден, используется fallback мутация

3. Выполнение мутации:
   - Если найден диапазон: `mutate_parameter_with_range()`
   - Иначе: `mutate_parameter_fallback()`

#### Мутация с диапазоном

**Функция**: `mutate_parameter_with_range()`

**Алгоритм**:

1. Вычисляется размер диапазона: `range_size = range.end - range.start`
2. Вычисляется процент мутации: `mutation_percent ∈ [param_mutation_min_percent, param_mutation_max_percent]`
3. Вычисляется абсолютная величина мутации: `mutation_amount = range_size * mutation_percent`
4. Определяются расстояния до границ:
   - `distance_to_start = current_value - range.start`
   - `distance_to_end = range.end - current_value`
5. Определяются максимальные мутации:
   - `max_mutation_up = min(distance_to_end, mutation_amount)`
   - `max_mutation_down = min(distance_to_start, mutation_amount)`
6. Выбирается направление мутации:
   - Если можно мутировать в обе стороны: `mutation ∈ [-max_mutation_down, max_mutation_up]`
   - Если можно только вверх: `mutation ∈ [0, max_mutation_up]`
   - Если можно только вниз: `mutation ∈ [-max_mutation_down, 0]`
   - Если нельзя мутировать: `mutation = 0`
7. Применяется мутация: `new_value = current_value + mutation`
8. Значение ограничивается диапазоном: `new_value = clamp(new_value, range.start, range.end)`

**Особенности**:
- Мутация всегда остается в допустимых границах
- Если значение на границе, мутация идет в противоположную сторону
- Для `Integer` значений результат округляется до целого числа
- Для `Flag` значений выполняется инверсия (true ↔ false)

#### Fallback мутация

**Функция**: `mutate_parameter_fallback()`

**Используется когда**: Диапазон параметра не определен

**Алгоритм**:

- Для `Number`: `mutation = random(-0.1, 0.1) * abs(current_value)`, `new_value = current_value + mutation`
- Для `Integer`: `mutation = random(-2, 2)`, `new_value = current_value + mutation`
- Для `Flag`: инверсия значения

#### Определение диапазонов параметров

**Функция**: `get_parameter_range()`

**Типы параметров и их диапазоны**:

1. **Параметры индикаторов** (`{indicator_name}_{param_name}`):
   - `period`: `[5.0, 200.0]` с шагом `1.0`
   - Определяется через `get_optimization_range(indicator_name, param_name, ParameterType::Period)`

2. **Параметры множителей** (`deviation`, `coeff_atr`):
   - `deviation` (для Bollinger Bands): `[0.5, 4.0]` с шагом `0.1`
   - `coeff_atr`: `[1.0, 10.0]` с шагом `0.1`
   - Определяется через `get_optimization_range(indicator_name, param_name, ParameterType::Multiplier)`

3. **Параметры порогов** (`threshold`):
   - Для RSI: `[20.0, 80.0]` с шагом `5.0`
   - Для Stochastic: `[10.0, 90.0]` с шагом `5.0`
   - Определяется через `get_optimization_range(indicator_name, param_name, ParameterType::Threshold)`

4. **Параметры стоп-обработчиков** (`stop_{handler_name}_{param_name}`):
   - Определяется через `get_stop_optimization_range(handler_name, param_name)`
   - Примеры:
     - `StopLossPct.percentage`: зависит от конфигурации стоп-обработчика
     - `ATRTrailStop.coeff_atr`: зависит от конфигурации стоп-обработчика

5. **Параметры условий** (`condition_{condition_id}_{param_name}`):
   - Определяется по типу индикатора, используемого в условии
   - Если условие использует RSI, то `threshold` будет иметь диапазон RSI

## Отбор с разнообразием

**Функция**: `select_with_diversity()`

**Метод**: Round-robin отбор с группировкой по стратегиям

**Алгоритм**:

1. **Группировка по стратегиям**:
   - Все особи группируются по уникальной сигнатуре стратегии
   - Сигнатура включает: индикаторы, вложенные индикаторы, условия, стоп-обработчики, тейк-обработчики, таймфреймы

2. **Сортировка внутри групп**:
   - Каждая группа сортируется по fitness (от лучшего к худшему)

3. **Round-robin отбор**:
   - По очереди берется по одной особи от каждой стратегии
   - Это обеспечивает разнообразие в популяции
   - Процесс повторяется пока не наберется `target_size` особей

**Цель**: Поддержание разнообразия стратегий в популяции, предотвращение доминирования одного типа стратегий

## Финальный отбор поколения

**Процесс**:

1. Объединяются текущая популяция (μ) и потомство (λ)
2. Применяется отбор с разнообразием для выбора μ лучших особей
3. Применяется элитизм: лучшие `elitism_count` особей из предыдущего поколения заменяют худших в новом поколении

## Пример полного цикла эволюции

### Поколение 0 (Инициализация)

```
Популяция: 100 случайных стратегий
Оценка: Каждая стратегия проходит бэктест, получает fitness
```

### Поколение 1

```
1. Отбор элиты: 5 лучших стратегий сохраняются
2. Создание потомства:
   - Выбираются 2 родителя (пропорциональная селекция)
   - Скрещивание структуры (вероятность 0.7):
     * Условия входа/выхода переносятся вместе с индикаторами
     * Стоп/тейк обработчики могут обмениваться
   - Скрещивание параметров (вероятность 0.7):
     * Uniform crossover для всех параметров
   - Мутация структуры (вероятность 0.1):
     * Может добавить/удалить индикатор
     * Может добавить/удалить условие
   - Мутация параметров (вероятность 0.1):
     * Каждый параметр мутирует с вероятностью 0.1
     * Мутация в пределах допустимого диапазона
3. Оценка потомства: Каждая новая стратегия проходит бэктест
4. Отбор: Round-robin отбор с разнообразием
5. Элитизм: 5 лучших из предыдущего поколения заменяют худших
```

### Поколение 2, 3, ... N

Процесс повторяется до достижения `max_generations` или других критериев остановки.

## Типы условий в системе

Система поддерживает несколько типов условий, которые могут использоваться в стратегиях:

### 1. `indicator_price` - Индикатор-Цена

**Описание**: Сравнение индикатора с полем цены (Open, High, Low, Close)

**Операторы**: GreaterThan, LessThan, CrossesAbove, CrossesBelow

**Примеры**:
- `SMA > Close` - SMA выше цены закрытия
- `RSI CrossesAbove Close` - RSI пересекает цену закрытия снизу вверх

**Специальные варианты**:
- **GreaterPercent**: Индикатор выше цены на определенный процент
  - Формат: `{indicator} > {price_field} на {percent}%`
  - Параметр оптимизации: `percentage` (обычно 0.1% - 5.0%)
- **LowerPercent**: Индикатор ниже цены на определенный процент
  - Формат: `{indicator} < {price_field} на {percent}%`
  - Параметр оптимизации: `percentage` (обычно 0.1% - 5.0%)

**Использование**: Базовый тип условия, используется для большинства индикаторов

### 2. `indicator_constant` - Индикатор-Константа

**Описание**: Сравнение индикатора с фиксированным значением

**Операторы**: GreaterThan, LessThan

**Используется для**:
- **Осцилляторов** (RSI, Stochastic, %R, CCI, MACD):
  - RSI > 70 (перекупленность)
  - RSI < 30 (перепроданность)
  - Stochastic > 80
  - Stochastic < 20
- **Volatility индикаторов** (ATR, WATR):
  - ATR > Close * 2.0% (волатильность выше 2% от цены)
  - Параметр оптимизации: `percentage` (обычно 0.2% - 10.0%)

**Параметры оптимизации**:
- `threshold` - пороговое значение для осцилляторов
- `percentage` - процент от цены для volatility индикаторов

**Диапазоны**:
- RSI: 20.0 - 80.0 (шаг 5.0)
- Stochastic: 10.0 - 90.0 (шаг 5.0)
- Volatility: 0.2% - 10.0% (шаг 0.1%)

### 3. `indicator_indicator` - Индикатор-Индикатор

**Описание**: Сравнение двух индикаторов между собой

**Операторы**: GreaterThan, LessThan, CrossesAbove, CrossesBelow, Between

**Примеры**:
- `SMA > EMA` - SMA выше EMA
- `RSI CrossesAbove Stochastic` - RSI пересекает Stochastic снизу вверх
- `MACD Between Signal и Histogram` - MACD между сигнальной линией и гистограммой

**Использование**: Для сравнения индикаторов одного типа или разных типов

### 4. `trend_condition` - Трендовые условия

**Описание**: Определение направления тренда индикатора

**Типы**:
- **RisingTrend**: Восходящий тренд (индикатор растет)
  - Оператор: GreaterThan
  - Формат: `{indicator} RisingTrend (period: {period})`
- **FallingTrend**: Нисходящий тренд (индикатор падает)
  - Оператор: LessThan
  - Формат: `{indicator} FallingTrend (period: {period})`

**Параметры**:
- `period` - период для определения тренда (обычно 5-50, шаг 1)

**Использование**: Может применяться к любым индикаторам для определения направления тренда

**Особенности**:
- Работает с одним индикатором (не требует второго операнда)
- Определяет направление тренда за указанный период
- Период оптимизируется в диапазоне 5-50

### Создание условий при инициализации популяции

При создании начальной популяции (в `CandidateBuilder`) используется более сложная логика:

1. **Для осцилляторов**: Создаются условия `indicator_constant` с пороговыми значениями
2. **Для volatility индикаторов**: Создаются условия `indicator_constant` с процентом от цены
3. **Для трендовых индикаторов**: Могут создаваться `trend_condition` (RisingTrend/FallingTrend)
4. **Для остальных**: Создаются `indicator_price` или `indicator_indicator` условия
5. **С процентом**: С вероятностью `use_percent_condition` создаются условия GreaterPercent/LowerPercent

### Создание условий при мутации

**⚠️ Текущее ограничение**: При мутации структуры стратегии всегда создаются только простые условия типа `"indicator_price"` без процентов и без учета типа индикатора.

**Планируемое улучшение**: В будущих версиях мутация должна учитывать:
- Тип индикатора (oscillator, volatility, trend)
- Вероятность создания процентных условий (GreaterPercent/LowerPercent)
- Вероятность создания трендовых условий (RisingTrend/FallingTrend)
- Вероятность создания условий индикатор-индикатор

## Важные особенности реализации

### Связность индикаторов и условий

- Индикаторы **никогда** не переносятся отдельно от условий
- При скрещивании переносятся условия вместе с их индикаторами
- При удалении индикатора автоматически удаляются все связанные условия
- При добавлении индикатора автоматически создается условие

### Связность таймфреймов и условий

- Таймфреймы переносятся вместе с условиями, которые их используют
- При удалении условий удаляются неиспользуемые таймфреймы
- Таймфреймы извлекаются из `primary_timeframe` и `secondary_timeframe` условий

### Валидация параметров

- Все параметры мутируются в пределах допустимых диапазонов
- Если параметр на границе диапазона, мутация идет в противоположную сторону
- Параметры никогда не выходят за допустимые границы

### Очистка неиспользуемых элементов

- После скрещивания и мутации удаляются:
  - Индикаторы, не используемые ни в одном условии
  - Таймфреймы, не используемые ни в одном условии
  - Условия, ссылающиеся на несуществующие индикаторы

## Параметры по умолчанию

```rust
population_size: 100
lambda_size: 100
max_generations: 50
crossover_rate: 0.7
mutation_rate: 0.1
elitism_count: 5
param_mutation_min_percent: 0.03  // 3% от диапазона
param_mutation_max_percent: 0.05  // 5% от диапазона
```

## Рекомендации по настройке

- **Увеличение `mutation_rate`** (0.15-0.2): Больше разнообразия, но может дестабилизировать хорошие решения
- **Уменьшение `mutation_rate`** (0.05-0.08): Более стабильная эволюция, но меньше разнообразия
- **Увеличение `crossover_rate`** (0.8-0.9): Больше обмена генетическим материалом
- **Увеличение `elitism_count`**: Сохранение большего количества лучших решений
- **Увеличение `param_mutation_max_percent`**: Более агрессивная мутация параметров

## Планируемые улучшения

### Улучшение мутации структуры

**Текущее состояние**: При мутации создаются только простые условия `indicator_price`

**Планируемые изменения**:

1. **Учет типа индикатора при создании условий**:
   - Для осцилляторов создавать `indicator_constant` условия
   - Для volatility индикаторов создавать `indicator_constant` с процентом
   - Для трендовых индикаторов создавать `trend_condition` с вероятностью

2. **Добавление процентных условий**:
   - С вероятностью `use_percent_condition` создавать GreaterPercent/LowerPercent
   - Параметр `percentage` будет оптимизироваться в диапазоне 0.1% - 5.0%

3. **Добавление условий индикатор-индикатор**:
   - С вероятностью `use_indicator_indicator_condition` создавать условия сравнения двух индикаторов
   - Требует наличия минимум двух индикаторов в стратегии

4. **Добавление трендовых условий**:
   - С вероятностью `use_trend_condition` создавать RisingTrend/FallingTrend
   - Параметр `period` будет оптимизироваться в диапазоне 5-50

**Преимущества**:
- Большее разнообразие стратегий
- Более эффективное использование осцилляторов и volatility индикаторов
- Возможность создания более сложных условий
- Соответствие логике создания начальной популяции

