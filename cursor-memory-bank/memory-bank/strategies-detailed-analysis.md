# Детальный анализ стратегий и статистических методов

**Проект**: Торговый алгоритмический движок на Rust  
**Дата создания**: 2025-12-05  
**Статус**: Аналитический документ

---

## Оглавление

1. [Модели волатильности (GARCH семейство)](#1-модели-волатильности-garch-семейство)
2. [Скрытые состояния и режимы (Markov, HMM)](#2-скрытые-состояния-и-режимы-markov-hmm)
3. [Временные ряды и прогнозирование (ARIMA семейство)](#3-временные-ряды-и-прогнозирование-arima-семейство)
4. [Коинтеграция и парный трейдинг](#4-коинтеграция-и-парный-трейдинг)
5. [Факторные модели](#5-факторные-модели)
6. [Нелинейные модели](#6-нелинейные-модели)
7. [Байесовские методы](#7-байесовские-методы)
8. [Спектральный анализ](#8-спектральный-анализ)
9. [Микроструктура рынка](#9-микроструктура-рынка)
10. [Риск-менеджмент](#10-риск-менеджмент)
11. [Многомерные методы (VAR, VECM)](#11-многомерные-методы-var-vecm)
12. [Стохастические процессы](#12-стохастические-процессы)
13. [Машинное обучение для временных рядов](#13-машинное-обучение-для-временных-рядов)

---

## 1. Модели волатильности (GARCH семейство)

### 1.1 GARCH (Generalized Autoregressive Conditional Heteroskedasticity)

**Описание**: Моделирует изменяющуюся во времени волатильность, где волатильность зависит от прошлых шоков и прошлой волатильности.

**Формула**:
```
σ²ₜ = ω + α·ε²ₜ₋₁ + β·σ²ₜ₋₁
```
где:
- σ²ₜ - условная дисперсия в момент t
- ω - константа (> 0)
- α - параметр ARCH эффекта
- β - параметр GARCH эффекта
- ε²ₜ₋₁ - квадрат прошлой ошибки

**Детальный расчет на реальных данных**:

**Пример: SPY (S&P 500 ETF) - GARCH(1,1) модель**

1. **Подготовка данных**:
   - Собираем дневные цены закрытия SPY за 2 года (500 торговых дней)
   - Вычисляем лог-доходности: rₜ = ln(Pₜ/Pₜ₋₁)
   - Пример: Pₜ₋₁ = 400.00, Pₜ = 402.00 → rₜ = ln(402/400) = 0.004975 ≈ 0.50%

2. **Оценка параметров методом максимального правдоподобия (MLE)**:
   - Инициализация: ω = 0.01, α = 0.1, β = 0.8
   - Условие стационарности: α + β = 0.1 + 0.8 = 0.9 < 1 ✓
   - Оптимизация через MLE дает: ω = 0.000012, α = 0.085, β = 0.91

3. **Пошаговый расчет условной волатильности**:
   
   День 1 (t=1):
   - ε₀ = 0 (начальное значение)
   - σ²₀ = ω/(1-α-β) = 0.000012/(1-0.085-0.91) = 0.000012/0.005 = 0.0024
   - σ₀ = √0.0024 = 0.049 = 4.9% (годовая волатильность)
   
   День 2 (t=2):
   - r₁ = 0.005 (доходность дня 1)
   - ε₁ = r₁ - μ = 0.005 - 0.0005 = 0.0045 (где μ = средняя доходность)
   - σ²₁ = 0.000012 + 0.085 × (0.0045)² + 0.91 × 0.0024
   - σ²₁ = 0.000012 + 0.085 × 0.00002025 + 0.002184
   - σ²₁ = 0.000012 + 0.00000172 + 0.002184 = 0.0021977
   - σ₁ = √0.0021977 = 0.0469 = 4.69%
   
   День 3 (t=3):
   - r₂ = -0.008 (негативная доходность)
   - ε₂ = -0.008 - 0.0005 = -0.0085
   - σ²₂ = 0.000012 + 0.085 × (-0.0085)² + 0.91 × 0.0021977
   - σ²₂ = 0.000012 + 0.085 × 0.00007225 + 0.002002
   - σ²₂ = 0.000012 + 0.00000614 + 0.002002 = 0.002020
   - σ₂ = √0.002020 = 0.0450 = 4.50%

4. **Прогнозирование волатильности на 1 шаг вперед**:
   - σ²ₜ₊₁ = ω + α·ε²ₜ + β·σ²ₜ
   - Если текущая σ²ₜ = 0.0020 и ε²ₜ = 0.0001:
   - σ²ₜ₊₁ = 0.000012 + 0.085 × 0.0001 + 0.91 × 0.0020
   - σ²ₜ₊₁ = 0.000012 + 0.0000085 + 0.00182 = 0.0018405
   - σₜ₊₁ = √0.0018405 = 0.0429 = 4.29%

5. **Торговые сигналы на основе GARCH**:
   - Низкая волатильность (σₜ < 0.02 = 2%): Вход в позицию (ожидание роста волатильности)
   - Высокая волатильность (σₜ > 0.05 = 5%): Выход из позиции или защита
   - Динамический размер позиции: size = base_size × (σ_target / σₜ)
     - Если σ_target = 0.03 и σₜ = 0.015, то size = 1.0 × (0.03/0.015) = 2.0 (увеличиваем позицию)

6. **Применение в VaR**:
   - 1-дневный VaR (95%): VaR = -μ - σₜ × 1.645
   - Если μ = 0.0005, σₜ = 0.03:
   - VaR = -0.0005 - 0.03 × 1.645 = -0.04985 ≈ -4.99%
   - Интерпретация: с вероятностью 95% потери не превысят 4.99% за день

**Сигнал**:
- Вход: Когда σ²ₜ < порог (низкая волатильность)
- Выход: Когда σ²ₜ > порог (высокая волатильность)

**Применимость**: ★★★★★ (Высокая)
- **Преимущества**: Базовая модель для volatility trading, VaR расчетов
- **Реализация**: Средняя сложность
- **Вычисления**: O(n), подходит для real-time
- **Использование**: Динамический sizing позиций, stop-loss адаптация, опционные стратегии

---

### 1.2 EGARCH (Exponential GARCH)

**Описание**: Захватывает асимметрию волатильности (leverage effect) - негативные шоки увеличивают волатильность сильнее.

**Формула**:
```
log(σ²ₜ) = ω + β·log(σ²ₜ₋₁) + α·|zₜ₋₁| + γ·zₜ₋₁
```
где:
- zₜ = εₜ/σₜ - стандартизованные остатки
- γ < 0 для leverage effect

**Детальный расчет на реальных данных**:

**Пример: S&P 500 Index - EGARCH(1,1) модель**

1. **Подготовка данных**:
   - Дневные доходности S&P 500 за период 2020-2023
   - Вычисляем стандартизованные остатки: zₜ = εₜ/σₜ

2. **Оценка параметров**:
   - Типичные оценки для equity markets:
     - ω = -0.5
     - β = 0.95 (высокая персистентность)
     - α = 0.15 (влияние абсолютных шоков)
     - γ = -0.10 (leverage effect, отрицательный)

3. **Пошаговый расчет**:

   День 1 (t=1):
   - Инициализация: log(σ²₀) = -3.0 → σ²₀ = exp(-3.0) = 0.0498, σ₀ = 0.223
   - ε₀ = 0.01, z₀ = 0.01/0.223 = 0.0448
   
   День 2 (t=2):
   - Негативный шок: ε₁ = -0.02 (падение на 2%)
   - z₁ = -0.02/0.223 = -0.0897
   - |z₁| = 0.0897
   - E[|z₁|] = √(2/π) ≈ 0.798 (для нормального распределения)
   - log(σ²₁) = -0.5 + 0.95 × (-3.0) + 0.15 × (0.0897 - 0.798) + (-0.10) × (-0.0897)
   - log(σ²₁) = -0.5 - 2.85 + 0.15 × (-0.7083) + 0.00897
   - log(σ²₁) = -0.5 - 2.85 - 0.1062 + 0.00897 = -3.447
   - σ²₁ = exp(-3.447) = 0.0319
   - σ₁ = √0.0319 = 0.1786 = 17.86% (годовая)
   
   **Интерпретация**: Негативный шок увеличил волатильность с 22.3% до 17.86% (в годовом выражении)

   День 3 (t=3):
   - Позитивный шок: ε₂ = 0.015 (рост на 1.5%)
   - z₂ = 0.015/0.1786 = 0.0840
   - log(σ²₂) = -0.5 + 0.95 × (-3.447) + 0.15 × (0.0840 - 0.798) + (-0.10) × 0.0840
   - log(σ²₂) = -0.5 - 3.275 + 0.15 × (-0.714) - 0.0084
   - log(σ²₂) = -0.5 - 3.275 - 0.1071 - 0.0084 = -3.890
   - σ²₂ = exp(-3.890) = 0.0204
   - σ₂ = √0.0204 = 0.1428 = 14.28%

   **Интерпретация**: Позитивный шок снизил волатильность (меньший эффект, чем негативный)

4. **Асимметричный эффект (Leverage Effect)**:
   - При γ = -0.10:
     - Негативный шок (z = -0.1): эффект = α × |z| + γ × z = 0.15 × 0.1 + (-0.10) × (-0.1) = 0.015 + 0.01 = 0.025
     - Позитивный шок (z = +0.1): эффект = 0.15 × 0.1 + (-0.10) × 0.1 = 0.015 - 0.01 = 0.005
   - **Вывод**: Негативные шоки увеличивают волатильность в 5 раз сильнее (0.025/0.005)

5. **Торговые сигналы**:
   - После негативного шока (ε < 0):
     - Волатильность резко растет → защитные стратегии
     - Увеличиваем stop-loss расстояния
     - Снижаем размер позиций: size = base_size × (σ_target / σₜ)
   - После позитивного шока (ε > 0):
     - Волатильность растет умеренно → можно увеличивать позиции
     - Более агрессивные стратегии допустимы

6. **VaR с учетом асимметрии**:
   - Для длинных позиций: VaR_long = -μ - σₜ × 1.645 × (1 + |γ|)
   - Если σₜ = 0.02, γ = -0.10:
   - VaR_long = -0.0005 - 0.02 × 1.645 × 1.1 = -0.0367 = -3.67%
   - Для коротких позиций: VaR_short = -μ - σₜ × 1.645 × (1 - |γ|) = -0.0329 = -3.29%
   - **Вывод**: Длинные позиции имеют больший риск из-за leverage effect

**Сигнал**:
- Негативный шок → повышенная волатильность → защитные стратегии
- Позитивный шок → умеренная волатильность → агрессивные стратегии

**Применимость**: ★★★★★ (Высокая)
- **Преимущества**: Лучше GARCH для equity markets с асимметрией
- **Реализация**: Средняя сложность
- **Использование**: VaR для длинных позиций, tail hedging

---

### 1.3 TGARCH / GJR-GARCH (Threshold GARCH)

**Описание**: Использует dummy-переменную для разделения позитивных/негативных шоков.

**Формула**:
```
σ²ₜ = ω + α·ε²ₜ₋₁ + γ·I(εₜ₋₁<0)·ε²ₜ₋₁ + β·σ²ₜ₋₁
```
где:
- I(εₜ₋₁<0) = 1 если шок негативный, иначе 0
- γ - дополнительный эффект от негативных шоков

**Детальный расчет на реальных данных**:

**Пример: Финансовый актив - TGARCH(1,1) модель**

1. **Оценка параметров**:
   - Типичные оценки: ω = 0.00001, α = 0.05, γ = 0.10, β = 0.85
   - Условие стационарности: α + γ/2 + β < 1 → 0.05 + 0.05 + 0.85 = 0.95 < 1 ✓

2. **Пошаговый расчет**:

   День 1 (t=1):
   - Инициализация: σ²₀ = ω/(1-α-β-γ/2) = 0.00001/0.05 = 0.0002
   - σ₀ = √0.0002 = 0.0141 = 1.41%
   
   День 2 (t=2):
   - Негативный шок: ε₁ = -0.03 (падение на 3%)
   - I(ε₁ < 0) = 1
   - σ²₁ = 0.00001 + 0.05 × (-0.03)² + 0.10 × 1 × (-0.03)² + 0.85 × 0.0002
   - σ²₁ = 0.00001 + 0.05 × 0.0009 + 0.10 × 0.0009 + 0.00017
   - σ²₁ = 0.00001 + 0.000045 + 0.00009 + 0.00017 = 0.000315
   - σ₁ = √0.000315 = 0.0177 = 1.77%
   - **Эффект негативного шока**: (α + γ) × ε² = (0.05 + 0.10) × 0.0009 = 0.000135
   
   День 3 (t=3):
   - Позитивный шок: ε₂ = 0.02 (рост на 2%)
   - I(ε₂ < 0) = 0
   - σ²₂ = 0.00001 + 0.05 × (0.02)² + 0.10 × 0 × (0.02)² + 0.85 × 0.000315
   - σ²₂ = 0.00001 + 0.05 × 0.0004 + 0 + 0.000268
   - σ²₂ = 0.00001 + 0.00002 + 0.000268 = 0.000298
   - σ₂ = √0.000298 = 0.0173 = 1.73%
   - **Эффект позитивного шока**: α × ε² = 0.05 × 0.0004 = 0.00002

3. **Сравнение эффектов**:
   - Негативный шок (ε = -0.03): вклад = (0.05 + 0.10) × 0.0009 = 0.000135
   - Позитивный шок (ε = +0.03): вклад = 0.05 × 0.0009 = 0.000045
   - **Отношение**: 0.000135 / 0.000045 = 3.0
   - **Вывод**: Негативные шоки увеличивают волатильность в 3 раза сильнее

4. **Торговые сигналы**:
   - После негативного шока:
     - Волатильность растет на (α + γ) = 0.15
     - Увеличиваем stop-loss: SL_new = SL_old × (1 + σ_increase)
     - Снижаем размер позиции на 20-30%
   - После позитивного шока:
     - Волатильность растет на α = 0.05 (меньше)
     - Можно поддерживать текущий размер позиции

**Сигнал**:
- Негативный шок → σ²ₜ растёт на (α+γ)
- Позитивный шок → σ²ₜ растёт на α

**Применимость**: ★★★★☆ (Хорошая)
- **Преимущества**: Простая интерпретация, быстрые вычисления
- **Использование**: Bear market hedging, динамический stop-loss

---

### 1.4 IGARCH (Integrated GARCH)

**Описание**: Специальный случай GARCH где α + β = 1, волатильность имеет постоянную память (unit root).

**Формула**:
```
σ²ₜ = ω + α·ε²ₜ₋₁ + (1-α)·σ²ₜ₋₁
```

**Сигнал**:
- Шоки имеют постоянный эффект → long volatility strategies

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Простота, persistence modeling
- **Недостатки**: Шоки не затухают
- **Использование**: VIX trading, volatility arbitrage

---

### 1.5 FIGARCH (Fractionally Integrated GARCH)

**Описание**: Долгая память в волатильности через дробную интеграцию.

**Формула**:
```
σ²ₜ = ω + [1 - (1-α·L)·(1-L)ᵈ·(1-β·L)⁻¹]·ε²ₜ
```
где:
- d ∈ (0, 1) - параметр долгой памяти
- L - лаговый оператор

**Сигнал**:
- d близко к 0.5 → сильная memory в волатильности

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Лучше для commodities/FX с долгой памятью
- **Сложность**: Высокая вычислительная
- **Использование**: Trend-following с Hurst > 0.5

---

### 1.6 NAGARCH (Nonlinear Asymmetric GARCH)

**Описание**: Нелинейные power transformations для моделирования экстремальных событий.

**Формула**:
```
σᵖₜ = ω + α·(|εₜ₋₁| - γ·εₜ₋₁)ᵖ + β·σᵖₜ₋₁
```
где:
- p - power parameter (обычно 1 или 2)

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Tail-risk hedging в equity/FX

---

### 1.7 APARCH (Asymmetric Power ARCH)

**Описание**: Обобщение многих ARCH моделей с гибкими power transformations.

**Формула**:
```
σᵟₜ = ω + Σᵢ αᵢ·(|εₜ₋ᵢ| - γᵢ·εₜ₋ᵢ)ᵟ + Σⱼ βⱼ·σᵟₜ₋ⱼ
```

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Максимальная гибкость
- **Недостатки**: Много параметров, overfitting риск

---

### 1.8 Component GARCH

**Описание**: Разделяет волатильность на краткосрочную и долгосрочную компоненты.

**Формула**:
```
σ²ₜ = qₜ + α·(ε²ₜ₋₁ - qₜ₋₁) + β·(σ²ₜ₋₁ - qₜ₋₁)
qₜ = ω + ρ·(ε²ₜ₋₁ - σ²ₜ₋₁) + φ·(qₜ₋₁ - ω)
```

**Сигнал**:
- Mean-reversion на spread между краткосрочной и долгосрочной волатильностью

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Volatility spread trading

---

### 1.9 DCC-GARCH (Dynamic Conditional Correlation)

**Описание**: Моделирует динамические корреляции между активами для портфельного управления.

**Формула**:
```
Hₜ = DₜRₜDₜ
Dₜ = diag(σ₁ₜ, ..., σₙₜ)
Rₜ = Q̄ₜ⁻¹QₜQ̄ₜ⁻¹
Qₜ = (1-a-b)Q̄ + a·zₜ₋₁z'ₜ₋₁ + b·Qₜ₋₁
```

**Детальный расчет на реальных данных**:

**Пример: Портфель из SPY и GLD (S&P 500 ETF и Gold ETF)**

1. **Шаг 1: Оценка индивидуальных GARCH моделей**:
   - SPY: σ²_SPY,t = 0.00001 + 0.1 × ε²_SPY,t-1 + 0.85 × σ²_SPY,t-1
   - GLD: σ²_GLD,t = 0.00002 + 0.12 × ε²_GLD,t-1 + 0.82 × σ²_GLD,t-1
   - На день t: σ_SPY,t = 0.02, σ_GLD,t = 0.015
   - Dₜ = diag(0.02, 0.015)

2. **Шаг 2: Стандартизация остатков**:
   - z_SPY,t = ε_SPY,t / σ_SPY,t = 0.01 / 0.02 = 0.5
   - z_GLD,t = ε_GLD,t / σ_GLD,t = -0.005 / 0.015 = -0.333
   - zₜ = [0.5, -0.333]ᵀ

3. **Шаг 3: Расчет безусловной корреляционной матрицы Q̄**:
   - Из исторических данных: Q̄ = [[1.0, 0.3], [0.3, 1.0]]
   - (средняя корреляция между SPY и GLD = 0.3)

4. **Шаг 4: Расчет динамической корреляционной матрицы Qₜ**:
   - Параметры: a = 0.05, b = 0.90
   - Qₜ₋₁ = [[1.0, 0.35], [0.35, 1.0]] (предыдущая оценка)
   - zₜ₋₁z'ₜ₋₁ = [[0.5], [-0.333]] × [[0.5, -0.333]] = [[0.25, -0.167], [-0.167, 0.111]]
   - Qₜ = (1 - 0.05 - 0.90) × Q̄ + 0.05 × zₜ₋₁z'ₜ₋₁ + 0.90 × Qₜ₋₁
   - Qₜ = 0.05 × [[1.0, 0.3], [0.3, 1.0]] + 0.05 × [[0.25, -0.167], [-0.167, 0.111]] + 0.90 × [[1.0, 0.35], [0.35, 1.0]]
   - Qₜ = [[0.05, 0.015], [0.015, 0.05]] + [[0.0125, -0.00835], [-0.00835, 0.00555]] + [[0.9, 0.315], [0.315, 0.9]]
   - Qₜ = [[0.9625, 0.32165], [0.32165, 0.95555]]

5. **Шаг 5: Нормализация к корреляционной матрице Rₜ**:
   - diag(Qₜ) = [0.9625, 0.95555]
   - diag(Qₜ)⁻¹/² = [1/√0.9625, 1/√0.95555] = [1.019, 1.023]
   - Rₜ = diag(Qₜ)⁻¹/² × Qₜ × diag(Qₜ)⁻¹/²
   - Rₜ = [[1.0, 0.335], [0.335, 1.0]]
   - **Корреляция увеличилась с 0.30 до 0.335** (кризисный режим)

6. **Шаг 6: Расчет ковариационной матрицы Hₜ**:
   - Hₜ = Dₜ × Rₜ × Dₜ
   - Hₜ = [[0.02, 0], [0, 0.015]] × [[1.0, 0.335], [0.335, 1.0]] × [[0.02, 0], [0, 0.015]]
   - Hₜ = [[0.0004, 0.0001005], [0.0001005, 0.000225]]
   - Ковариация: Cov(SPY, GLD) = 0.0001005
   - Корреляция: ρ = 0.0001005 / (0.02 × 0.015) = 0.335 ✓

7. **Торговые сигналы**:
   - Увеличение корреляции (ρ > 0.4):
     - Снижение диверсификации → уменьшаем размер портфеля
     - Увеличиваем хеджирование: hedge_ratio = -ρ × (σ_SPY / σ_GLD)
   - Снижение корреляции (ρ < 0.2):
     - Улучшение диверсификации → можно увеличивать позиции
     - Оптимальные веса: w_SPY = (σ²_GLD - Cov) / (σ²_SPY + σ²_GLD - 2×Cov)

8. **Оптимизация портфеля**:
   - Минимальная дисперсия: w* = (Hₜ⁻¹ × 1) / (1ᵀ × Hₜ⁻¹ × 1)
   - При Hₜ = [[0.0004, 0.0001005], [0.0001005, 0.000225]]:
   - w_SPY = 0.35, w_GLD = 0.65 (золото имеет меньшую волатильность)

**Сигнал**:
- Увеличение корреляции → снижение диверсификации → hedge
- Снижение корреляции → увеличение позиций

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Dynamic hedging, pairs trading, multi-asset portfolios

---

### 1.10 Realized Volatility (RV)

**Описание**: Ex-post оценка волатильности из high-frequency данных.

**Формула**:
```
RVₜ = Σᵢ r²ₜ,ᵢ
```
где rₜ,ᵢ - intraday returns

**Детальный расчет на реальных данных**:

**Пример: SPY (S&P 500 ETF) - 5-минутные данные за торговый день**

1. **Подготовка данных**:
   - Торговый день: 9:30 - 16:00 (6.5 часов = 390 минут)
   - Интервал: 5 минут → 78 наблюдений за день
   - Цены закрытия (5-минутные бары):
     - 9:30: P₀ = 183.98
     - 9:35: P₁ = 184.10
     - 9:40: P₂ = 183.95
     - 9:45: P₃ = 184.25
     - ... (до 16:00)

2. **Расчет внутридневных доходностей**:
   - rₜ,₁ = ln(P₁/P₀) = ln(184.10/183.98) = 0.000652
   - rₜ,₂ = ln(P₂/P₁) = ln(183.95/184.10) = -0.000815
   - rₜ,₃ = ln(P₃/P₂) = ln(184.25/183.95) = 0.001629
   - ... (продолжаем для всех 78 интервалов)

3. **Расчет Realized Variance**:
   - RVₜ = Σᵢ₌₁⁷⁸ r²ₜ,ᵢ
   - RVₜ = (0.000652)² + (-0.000815)² + (0.001629)² + ...
   - RVₜ = 0.000000425 + 0.000000664 + 0.000002653 + ...
   - RVₜ = 0.00085 (сумма всех 78 квадратов)

4. **Realized Volatility (дневная)**:
   - RVₜ = √0.00085 = 0.0292 = 2.92% (дневная волатильность)

5. **Годовая волатильность**:
   - RV_annual = √(RVₜ × 252) = √(0.00085 × 252) = √0.2142 = 0.4628 = 46.28%
   - **Интерпретация**: Годовая волатильность составляет 46.28%

6. **Сравнение с GARCH**:
   - GARCH прогноз: σ_GARCH = 0.025 (2.5% дневная)
   - Realized Volatility: σ_RV = 0.0292 (2.92% дневная)
   - **Вывод**: Реализованная волатильность выше прогноза GARCH (рынок более волатилен)

7. **Применение в торговле**:
   - **VIX Trading**: RV используется для калибровки VIX моделей
   - **HAR Model**: RV как входная переменная для прогнозирования
   - **Risk Management**: Более точная оценка риска, чем GARCH
   - **Volatility Arbitrage**: Сравнение RV с implied volatility опционов

8. **Учет микроструктурного шума**:
   - При очень высоких частотах (1-минутные данные) появляется шум
   - Решение: использовать 5-10 минутные интервалы
   - Или: применять двухскоростную реализованную волатильность (TSRV)

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Улучшает HAR-GARCH прогнозы, VIX trading

---

## 2. Скрытые состояния и режимы (Markov, HMM)

### 2.1 Hidden Markov Models (HMM)

**Описание**: Моделирует скрытые состояния рынка (бычий/медвежий/боковой) с наблюдаемыми emissions (цены/returns).

**Формула**:
```
P(Sₜ|Sₜ₋₁) - матрица переходов
P(Oₜ|Sₜ) - emission probabilities
```

**Детальный расчет на реальных данных**:

**Пример: S&P 500 - 3 состояния (Bull, Bear, Sideways)**

1. **Инициализация модели**:
   - Состояния: S₁ = Bull (бычий), S₂ = Bear (медвежий), S₃ = Sideways (боковой)
   - Начальные вероятности: π = [0.4, 0.3, 0.3]
   - Матрица переходов A:
     ```
     A = [[0.85, 0.10, 0.05],   # Из Bull
          [0.15, 0.75, 0.10],   # Из Bear
          [0.20, 0.20, 0.60]]   # Из Sideways
     ```
   - Emission probabilities (нормальное распределение):
     - Bull: μ = 0.001, σ = 0.015 (положительная доходность, низкая волатильность)
     - Bear: μ = -0.001, σ = 0.025 (отрицательная доходность, высокая волатильность)
     - Sideways: μ = 0.000, σ = 0.010 (около нуля, средняя волатильность)

2. **Forward Algorithm (фильтрация)**:

   День 1 (t=1):
   - Наблюдаемая доходность: r₁ = 0.012 (1.2%)
   - α₁(Bull) = π₁ × b₁(r₁) = 0.4 × N(0.012 | μ=0.001, σ=0.015)
   - N(0.012 | 0.001, 0.015) = (1/√(2π×0.015²)) × exp(-0.5 × ((0.012-0.001)/0.015)²)
   - N(0.012 | 0.001, 0.015) = 26.53 × exp(-0.5 × 0.5378) = 26.53 × 0.764 = 20.27
   - α₁(Bull) = 0.4 × 20.27 = 8.108
   
   - α₁(Bear) = 0.3 × N(0.012 | -0.001, 0.025) = 0.3 × 15.96 × exp(-0.5 × 0.2704) = 0.3 × 15.96 × 0.874 = 4.18
   - α₁(Sideways) = 0.3 × N(0.012 | 0.000, 0.010) = 0.3 × 39.89 × exp(-0.5 × 1.44) = 0.3 × 39.89 × 0.487 = 5.83
   
   - Нормализация: P(O₁) = 8.108 + 4.18 + 5.83 = 18.118
   - α₁(Bull) = 8.108 / 18.118 = 0.447
   - α₁(Bear) = 4.18 / 18.118 = 0.231
   - α₁(Sideways) = 5.83 / 18.118 = 0.322
   
   **Вывод**: Наиболее вероятное состояние - Bull (44.7%)

   День 2 (t=2):
   - Наблюдаемая доходность: r₂ = -0.008 (-0.8%)
   - α₂(Bull) = [α₁(Bull)×A₁₁ + α₁(Bear)×A₂₁ + α₁(Sideways)×A₃₁] × b₁(r₂)
   - α₂(Bull) = [0.447×0.85 + 0.231×0.15 + 0.322×0.20] × N(-0.008 | 0.001, 0.015)
   - α₂(Bull) = [0.380 + 0.035 + 0.064] × 19.95 × exp(-0.5 × 0.36) = 0.479 × 19.95 × 0.835 = 7.98
   
   - α₂(Bear) = [0.447×0.10 + 0.231×0.75 + 0.322×0.20] × N(-0.008 | -0.001, 0.025)
   - α₂(Bear) = [0.045 + 0.173 + 0.064] × 15.96 × exp(-0.5 × 0.0784) = 0.282 × 15.96 × 0.962 = 4.33
   
   - Нормализация: P(O₂|O₁) = 7.98 + 4.33 + 3.21 = 15.52
   - α₂(Bull) = 0.514, α₂(Bear) = 0.279, α₂(Sideways) = 0.207
   
   **Вывод**: Вероятность Bull снизилась до 51.4%, Bear выросла до 27.9%

3. **Viterbi Algorithm (наиболее вероятная последовательность)**:

   День 1: δ₁(Bull) = 0.447, δ₁(Bear) = 0.231, δ₁(Sideways) = 0.322 → q₁* = Bull
   
   День 2:
   - δ₂(Bull) = max[0.447×0.85, 0.231×0.15, 0.322×0.20] × b₁(r₂) = 0.380 × 0.479 = 0.182
   - δ₂(Bear) = max[0.447×0.10, 0.231×0.75, 0.322×0.20] × b₂(r₂) = 0.173 × 0.282 = 0.049
   - q₂* = Bull (из Bull, т.к. 0.447×0.85 максимально)
   
   **Вывод**: Наиболее вероятная последовательность: [Bull, Bull]

4. **Торговые сигналы**:
   - Если P(Bull|rₜ) > 0.6: Long позиция
   - Если P(Bear|rₜ) > 0.6: Short позиция или выход
   - Если P(Sideways|rₜ) > 0.5: Нейтральная позиция, ожидание
   
   - Адаптация параметров стратегии:
     - Bull режим: агрессивные параметры (SMA(10), высокий риск)
     - Bear режим: консервативные параметры (SMA(50), низкий риск)
     - Sideways: range trading стратегии

**Алгоритмы**:
- Forward-Backward для фильтрации состояний
- Viterbi для наиболее вероятной последовательности
- Baum-Welch для обучения параметров

**Сигнал**:
- Переход в бычье состояние → Long
- Переход в медвежье состояние → Short
- Боковой рынок → нейтральная позиция

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Regime detection, adaptive strategies
- **Вычисления**: O(n·K²), где K - число состояний

---

### 2.2 Markov-Switching Models

**Описание**: Параметры модели меняются в зависимости от режима (скрытого состояния).

**Формула**:
```
yₜ = μ(Sₜ) + Σᵢ φᵢ(Sₜ)·yₜ₋ᵢ + σ(Sₜ)·εₜ
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Cycle detection, regime-adaptive parameters

---

### 2.3 Markov-Switching VAR (MS-VAR)

**Описание**: Векторная авторегрессия с переключающимися режимами для множественных активов.

**Применимость**: ★★★☆☆ (Средняя)
- **Сложность**: Высокая вычислительная
- **Использование**: Multi-asset regime detection

---

### 2.4 Infinite Hidden Markov Model (iHMM)

**Описание**: HMM с автоматическим определением числа состояний через Dirichlet process.

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Не нужно задавать число режимов
- **Недостатки**: Высокая сложность
- **Использование**: Sticky regimes, crisis detection

---

## 3. Временные ряды и прогнозирование (ARIMA семейство)

### 3.1 ARIMA (Autoregressive Integrated Moving Average)

**Описание**: Комбинация авторегрессии (AR), интеграции (I) и скользящего среднего (MA).

**Формула**:
```
ARIMA(p,d,q):
(1 - Σφᵢ·Lⁱ)·(1-L)ᵈ·yₜ = (1 + Σθⱼ·Lʲ)·εₜ
```
где:
- p - порядок AR
- d - порядок дифференцирования
- q - порядок MA

**Детальный расчет на реальных данных**:

**Пример: AAPL (Apple Inc.) - ARIMA(2,1,2) модель**

1. **Подготовка данных**:
   - Дневные цены закрытия AAPL за 500 дней
   - Цены: P = [150.0, 151.2, 149.8, 152.5, ...]
   - Лог-доходности: rₜ = ln(Pₜ/Pₜ₋₁)
   - r = [0.0079, -0.0093, 0.0179, ...]

2. **Проверка стационарности (ADF тест)**:
   - H₀: ряд имеет unit root (нестационарен)
   - ADF статистика = -1.2, p-value = 0.68 > 0.05
   - **Вывод**: Ряд нестационарен → требуется дифференцирование

3. **Дифференцирование (d=1)**:
   - Δrₜ = rₜ - rₜ₋₁
   - Δr = [0.0079-0, -0.0093-0.0079, 0.0179-(-0.0093), ...]
   - Δr = [0.0079, -0.0172, 0.0272, ...]
   - Повторный ADF тест: p-value = 0.02 < 0.05 → стационарен ✓

4. **Определение параметров (p, q) через ACF/PACF**:
   - ACF: значимые лаги на 1, 2 → q = 2
   - PACF: значимые лаги на 1, 2 → p = 2
   - **Модель**: ARIMA(2,1,2)

5. **Оценка параметров методом максимального правдоподобия**:
   - AR коэффициенты: φ₁ = 0.35, φ₂ = -0.15
   - MA коэффициенты: θ₁ = 0.25, θ₂ = 0.10
   - Дисперсия шока: σ² = 0.0004

6. **Пошаговый расчет прогноза**:

   День t (текущий):
   - rₜ = 0.012, rₜ₋₁ = 0.008, rₜ₋₂ = -0.005
   - εₜ = 0.001, εₜ₋₁ = -0.002, εₜ₋₂ = 0.003
   
   Прогноз на t+1:
   - ŷₜ₊₁ = φ₁ × rₜ + φ₂ × rₜ₋₁ + εₜ₊₁ + θ₁ × εₜ + θ₂ × εₜ₋₁
   - ŷₜ₊₁ = 0.35 × 0.012 + (-0.15) × 0.008 + 0 + 0.25 × 0.001 + 0.10 × (-0.002)
   - ŷₜ₊₁ = 0.0042 - 0.0012 + 0.00025 - 0.0002 = 0.00305 ≈ 0.31%
   
   Прогноз цены:
   - P̂ₜ₊₁ = Pₜ × exp(ŷₜ₊₁) = 150.0 × exp(0.00305) = 150.46

7. **Интервалы прогноза (95% доверительный)**:
   - σ_forecast = σ × √(1 + Σθᵢ²) = 0.02 × √(1 + 0.25² + 0.10²) = 0.02 × 1.033 = 0.0207
   - Нижняя граница: Pₜ₊₁_lower = Pₜ × exp(ŷₜ₊₁ - 1.96 × σ_forecast) = 150.0 × exp(0.00305 - 0.0406) = 150.0 × 0.963 = 144.45
   - Верхняя граница: Pₜ₊₁_upper = 150.0 × exp(0.00305 + 0.0406) = 150.0 × 1.045 = 156.75

8. **Торговые сигналы**:
   - Если ŷₜ₊₁ > 0.005 (0.5%): Long сигнал
   - Если ŷₜ₊₁ < -0.005 (-0.5%): Short сигнал
   - Если |ŷₜ₊₁| < 0.002: Нейтральная позиция
   
   В нашем примере: ŷₜ₊₁ = 0.31% < 0.5% → **Слабый сигнал, ожидание**

9. **Модельная диагностика**:
   - Ljung-Box тест остатков: p-value = 0.42 > 0.05 → остатки некоррелированы ✓
   - AIC = -1250.3, BIC = -1235.8
   - Сравнение с ARIMA(1,1,1): AIC = -1245.1 → ARIMA(2,1,2) лучше

**Сигнал**:
- ŷₜ₊₁ > yₜ + threshold → Long
- ŷₜ₊₁ < yₜ - threshold → Short

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Прогнозирование трендов, mean-reversion
- **Подбор**: AIC/BIC для выбора (p,d,q)

---

### 3.2 ARFIMA (Autoregressive Fractionally Integrated MA)

**Описание**: ARIMA с дробной интеграцией для моделирования долгой памяти.

**Формула**:
```
(1 - Σφᵢ·Lⁱ)·(1-L)ᵈ·yₜ = (1 + Σθⱼ·Lʲ)·εₜ
```
где d ∈ (-0.5, 0.5) - дробный порядок

**Сигнал**:
- d > 0 → persistence, trend-following
- d < 0 → anti-persistence, mean-reversion

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Commodities с долгой памятью

---

### 3.3 Periodic AR

**Описание**: Коэффициенты AR меняются периодически (например, по дням недели).

**Формула**:
```
yₜ = Σᵢ φᵢ(t mod s)·yₜ₋ᵢ + εₜ
```
где s - период (например, 5 для недельной периодичности)

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Day-of-week effects, seasonal patterns

---

## 4. Коинтеграция и парный трейдинг

### 4.1 Engle-Granger Two-Step

**Описание**: Тест на коинтеграцию двух временных рядов для pairs trading.

**Шаги**:
1. Регрессия: y₁ₜ = α + β·y₂ₜ + uₜ
2. ADF тест на uₜ

**Детальный расчет на реальных данных**:

**Пример: GLD (Gold ETF) и SLV (Silver ETF) - Pairs Trading**

1. **Шаг 1: OLS регрессия для оценки hedge ratio**:
   - Данные: 500 дней цен GLD и SLV
   - GLD: [180.5, 181.2, 179.8, 182.1, ...]
   - SLV: [25.3, 25.5, 25.1, 25.7, ...]
   
   Регрессия: GLDₜ = α + β × SLVₜ + uₜ
   - Оценки: α = 2.5, β = 7.15
   - R² = 0.92 (высокая корреляция)
   - **Hedge ratio**: β = 7.15 (на 1 доллар SLV нужно 7.15 долларов GLD)

2. **Шаг 2: Расчет остатков (spread)**:
   - uₜ = GLDₜ - (2.5 + 7.15 × SLVₜ)
   - День 1: u₁ = 180.5 - (2.5 + 7.15 × 25.3) = 180.5 - 183.4 = -2.9
   - День 2: u₂ = 181.2 - (2.5 + 7.15 × 25.5) = 181.2 - 185.8 = -4.6
   - День 3: u₃ = 179.8 - (2.5 + 7.15 × 25.1) = 179.8 - 182.5 = -2.7
   - u = [-2.9, -4.6, -2.7, 1.2, 3.5, -1.8, ...]

3. **Шаг 3: ADF тест на стационарность остатков**:
   - H₀: остатки имеют unit root (нестационарны)
   - ADF статистика = -3.85
   - Критическое значение (5%) = -2.87
   - **Вывод**: -3.85 < -2.87 → отклоняем H₀ → остатки стационарны ✓
   - **Коинтеграция подтверждена!**

4. **Шаг 4: Расчет spread и z-score**:
   - Spreadₜ = GLDₜ - 7.15 × SLVₜ (без константы для торговли)
   - Rolling window: 60 дней для μ и σ
   
   День 100:
   - Spread₁₀₀ = 182.0 - 7.15 × 25.4 = 182.0 - 181.6 = 0.4
   - μ_spread (60 дней) = -0.5
   - σ_spread (60 дней) = 2.1
   - z-score = (0.4 - (-0.5)) / 2.1 = 0.9 / 2.1 = 0.43
   
   День 150:
   - Spread₁₅₀ = 185.0 - 7.15 × 25.2 = 185.0 - 180.2 = 4.8
   - μ_spread = -0.3, σ_spread = 2.0
   - z-score = (4.8 - (-0.3)) / 2.0 = 5.1 / 2.0 = 2.55

5. **Торговые сигналы**:
   - **z-score = 2.55 > +2.0**: 
     - Spread слишком высокий → ожидается сжатие
     - **Действие**: Short spread
       - Продать GLD: -1 акция × $185.0 = -$185.0
       - Купить SLV: +7.15 акций × $25.2 = +$180.2
       - Net position: -$4.8 (market neutral)
   
   День 200:
   - Spread₁₅₀ сжался до: 183.5 - 7.15 × 25.5 = 183.5 - 182.3 = 1.2
   - z-score = (1.2 - (-0.3)) / 2.0 = 0.75
   - **Действие**: Закрыть позицию (|z-score| < 0.5 не достигнут, но прибыль есть)
     - Купить GLD: +1 акция × $183.5 = +$183.5
     - Продать SLV: -7.15 акций × $25.5 = -$182.3
     - Прибыль: $185.0 - $183.5 + $182.3 - $180.2 = $3.6

6. **Обратный сигнал (z-score < -2)**:
   - День 250: Spread = -5.2, z-score = -2.6
   - **Действие**: Long spread
     - Купить GLD: +1 акция × $180.0 = +$180.0
     - Продать SLV: -7.15 акций × $25.9 = -$185.2
     - Net position: -$5.2

**Формула spread**:
```
spreadₜ = y₁ₜ - β·y₂ₜ
z-score = (spreadₜ - μ) / σ
```

**Сигнал**:
- z-score > +2 → Short spread (sell y₁, buy y₂)
- z-score < -2 → Long spread (buy y₁, sell y₂)
- |z-score| < 0.5 → Close position

**Применимость**: ★★★★★ (Высокая)
- **Примеры**: GLD-SLV, SPY-IWM
- **Использование**: Statistical arbitrage, mean-reversion

---

### 4.2 Johansen Cointegration Test

**Описание**: Многомерная коинтеграция для basket stat arb (5+ активов).

**Формула**:
```
Δyₜ = Π·yₜ₋₁ + Σᵢ Γᵢ·Δyₜ₋ᵢ + εₜ
Π = α·β'
```
где β - коинтеграционные векторы

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Multi-leg arbitrage, sector ETF baskets

---

### 4.3 Dynamic Cointegration (Kalman Filter)

**Описание**: Time-varying hedge ratios для адаптивного stat arb.

**Формула**:
```
βₜ = βₜ₋₁ + wₜ
y₁ₜ = βₜ·y₂ₜ + vₜ
```

**Детальный расчет на реальных данных**:

**Пример: SPY и IWM (S&P 500 и Russell 2000 ETFs) - Adaptive Hedge Ratio**

1. **State Space модель**:
   - State: βₜ (hedge ratio) - скрытое состояние
   - Observation: y₁ₜ = βₜ × y₂ₜ + vₜ (spread)
   - Process noise: wₜ ~ N(0, Q), Q = 0.0001
   - Measurement noise: vₜ ~ N(0, R), R = 0.5

2. **Инициализация Kalman Filter**:
   - β₀ = 0.5 (начальная оценка hedge ratio)
   - P₀ = 1.0 (начальная неопределенность)

3. **Пошаговый расчет**:

   День 1 (t=1):
   - **Prediction**:
     - β̂₁|₀ = β₀ = 0.5
     - P₁|₀ = P₀ + Q = 1.0 + 0.0001 = 1.0001
   
   - **Update**:
     - Наблюдаем: SPY₁ = 400.0, IWM₁ = 200.0
     - y₁ = SPY₁ = 400.0
     - z₁ = IWM₁ = 200.0
     - Kalman Gain: K₁ = P₁|₀ × z₁ / (z₁² × P₁|₀ + R)
     - K₁ = 1.0001 × 200 / (200² × 1.0001 + 0.5) = 200.02 / 40040.52 = 0.004995
     - Обновление: β̂₁|₁ = β̂₁|₀ + K₁ × (y₁ - z₁ × β̂₁|₀)
     - β̂₁|₁ = 0.5 + 0.004995 × (400.0 - 200.0 × 0.5) = 0.5 + 0.004995 × 300 = 0.5 + 1.499 = 1.999
     - P₁|₁ = (1 - K₁ × z₁) × P₁|₀ = (1 - 0.004995 × 200) × 1.0001 = 0.001 × 1.0001 = 0.001
   
   **Вывод**: Hedge ratio обновился с 0.5 до 1.999 (почти 2.0)

   День 2 (t=2):
   - **Prediction**:
     - β̂₂|₁ = β̂₁|₁ = 1.999
     - P₂|₁ = P₁|₁ + Q = 0.001 + 0.0001 = 0.0011
   
   - **Update**:
     - SPY₂ = 402.0, IWM₂ = 201.0
     - K₂ = 0.0011 × 201 / (201² × 0.0011 + 0.5) = 0.2211 / 44.64 = 0.00495
     - β̂₂|₂ = 1.999 + 0.00495 × (402.0 - 201.0 × 1.999) = 1.999 + 0.00495 × 0.201 = 2.000
     - P₂|₂ = (1 - 0.00495 × 201) × 0.0011 ≈ 0.0001

4. **Расчет адаптивного spread**:
   - Spreadₜ = SPYₜ - β̂ₜ|ₜ × IWMₜ
   - День 1: Spread₁ = 400.0 - 1.999 × 200.0 = 0.2
   - День 2: Spread₂ = 402.0 - 2.000 × 201.0 = 0.0
   - День 3: Spread₃ = 401.0 - 2.000 × 200.5 = 0.0

5. **Адаптивный z-score**:
   - Rolling mean: μ_spread (20 дней) = 0.1
   - Rolling std: σ_spread (20 дней) = 0.5
   - z-score = (Spreadₜ - μ_spread) / σ_spread
   - День 50: Spread = 1.5, z-score = (1.5 - 0.1) / 0.5 = 2.8
   - **Сигнал**: z-score > 2.0 → Short spread

6. **Преимущества адаптивного подхода**:
   - Hedge ratio меняется: βₜ ∈ [1.8, 2.2] (в зависимости от режима)
   - В кризис: β увеличивается (больше корреляция)
   - В спокойные времена: β стабилен около 2.0

**Сигнал**:
- spreadₜ = y₁ₜ - βₜ·y₂ₜ
- Adaptive z-score

**Применимость**: ★★★★★ (Высокая)
- **Преимущества**: Адаптация к меняющимся режимам
- **Использование**: Adaptive pairs trading

---

### 4.4 Fractional Cointegration

**Описание**: Коинтеграция с дробным порядком интеграции.

**Применимость**: ★★☆☆☆ (Низкая)
- **Сложность**: Очень высокая
- **Использование**: Специализированные исследовательские стратегии

---

## 5. Факторные модели

### 5.1 Fama-French 5-Factor Model

**Описание**: Мультифакторная регрессия для alpha extraction.

**Формула**:
```
Rᵢₜ - Rғₜ = αᵢ + βₘ(RMₜ-Rғₜ) + βₛSMBₜ + βₕHMLₜ + βᵣRMWₜ + βcCMAₜ + εᵢₜ
```
где:
- RM - Market excess return
- SMB - Size factor (Small Minus Big)
- HML - Value factor (High Minus Low book-to-market)
- RMW - Profitability factor
- CMA - Investment factor

**Детальный расчет на реальных данных**:

**Пример: Портфель акций технологического сектора - Fama-French 5-Factor**

1. **Подготовка данных (месячные данные за 60 месяцев)**:
   - Портфель доходность: Rₚ = [0.025, -0.015, 0.032, ...]
   - Безрисковая ставка: Rғ = 0.002 (0.2% в месяц)
   - Market excess: RM-Rғ = [0.018, -0.012, 0.025, ...]
   - SMB = [0.003, -0.002, 0.005, ...]
   - HML = [-0.001, 0.004, -0.002, ...]
   - RMW = [0.002, 0.001, 0.003, ...]
   - CMA = [-0.001, 0.002, -0.001, ...]

2. **Множественная регрессия**:
   - Зависимая переменная: Rₚ - Rғ
   - Независимые: RM-Rғ, SMB, HML, RMW, CMA
   
   Оценки коэффициентов:
   - α = 0.0035 (0.35% в месяц = 4.2% годовых) ✓ Положительный alpha!
   - βₘ = 1.15 (высокая чувствительность к рынку)
   - βₛ = 0.25 (небольшой tilt к small-cap)
   - βₕ = -0.10 (growth tilt, отрицательный value)
   - βᵣ = 0.15 (profitability exposure)
   - βc = -0.05 (aggressive investment)

3. **Пошаговый расчет для месяца t**:
   - Rₚₜ - Rғₜ = 0.0035 + 1.15 × (RMₜ-Rғₜ) + 0.25 × SMBₜ - 0.10 × HMLₜ + 0.15 × RMWₜ - 0.05 × CMAₜ + εₜ
   
   Пример месяца:
   - RM-Rғ = 0.020, SMB = 0.004, HML = -0.002, RMW = 0.003, CMA = -0.001
   - Ожидаемая доходность = 0.0035 + 1.15 × 0.020 + 0.25 × 0.004 - 0.10 × (-0.002) + 0.15 × 0.003 - 0.05 × (-0.001)
   - Ожидаемая доходность = 0.0035 + 0.023 + 0.001 + 0.0002 + 0.00045 + 0.00005 = 0.0282 = 2.82%
   - Фактическая доходность = 3.0%
   - Residual (alpha contribution) = 3.0% - 2.82% = 0.18% (положительный)

4. **Интерпретация результатов**:
   - **Alpha = 0.35% в месяц**: Портфель генерирует 4.2% годовых сверх факторов
   - **βₘ = 1.15**: Портфель на 15% более волатилен, чем рынок
   - **βₕ = -0.10**: Growth tilt (отрицательный value)
   - **R² = 0.88**: 88% дисперсии объясняется факторами

5. **Торговые сигналы**:
   - **Положительный α (статистически значимый, t > 2)**:
     - Long позиция в портфеле
     - Увеличить allocation на величину alpha
   
   - **Отрицательный α**:
     - Short позиция или избегание
     - Снизить allocation

6. **Factor timing стратегия**:
   - Если SMB > 0.005 (сильный small-cap эффект):
     - Увеличить βₛ exposure
   - Если HML > 0.003 (value outperformance):
     - Переключиться на value портфель (βₕ > 0)

**Сигнал**:
- Положительный α → Long
- Отрицательный α → Short

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Smart beta, long-short portfolios, factor timing

---

### 5.2 Carhart 4-Factor Model

**Описание**: Fama-French 3-factor + Momentum.

**Формула**:
```
Rᵢₜ - Rғₜ = αᵢ + βₘ(RMₜ-Rғₜ) + βₛSMBₜ + βₕHMLₜ + βᵤUMDₜ + εᵢₜ
```
где UMD - Momentum factor (Up Minus Down)

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Momentum + value strategies

---

### 5.3 APT (Arbitrage Pricing Theory)

**Описание**: Многомерная факторная модель с произвольными факторами.

**Формула**:
```
Rᵢ = Rғ + Σⱼ βᵢⱼ·Fⱼ + εᵢ
```

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Risk premia identification в ETF baskets

---

### 5.4 ICAPM (Intertemporal CAPM)

**Описание**: Динамические факторы с hedging portfolios для macro-aware positioning.

**Применимость**: ★★★☆☆ (Средняя)
- **Сложность**: Высокая теоретическая
- **Использование**: Macro hedging strategies

---

### 5.5 Dynamic Factor Models (DFM)

**Описание**: Извлекает латентные факторы из high-dimensional данных.

**Формула**:
```
Xₜ = Λ·Fₜ + εₜ
Fₜ = Φ·Fₜ₋₁ + ηₜ
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Macro-FX positioning, dimensionality reduction

---

### 5.6 Principal Component Analysis (PCA) for Factors

**Описание**: Снижение размерности через главные компоненты.

**Формула**:
```
PC = X·V
```
где V - собственные векторы ковариационной матрицы

**Сигнал**:
- Первые PC объясняют рыночный риск
- Ортогональные PC - специфические риски

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Noise filtering, portfolio construction, risk management

---

### 5.7 Functional PCA (FPCA)

**Описание**: PCA для функциональных данных (например, intraday curves).

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: High-frequency pattern recognition, momentum signals

---

## 6. Нелинейные модели

### 6.1 SETAR (Self-Exciting Threshold AR)

**Описание**: AR модель с резкими переходами между режимами по threshold.

**Формула**:
```
yₜ = φ₁·yₜ₋₁ + ... + εₜ,  если yₜ₋ₐ ≤ r
yₜ = ψ₁·yₜ₋₁ + ... + εₜ,  если yₜ₋ₐ > r
```
где r - threshold, d - delay parameter

**Сигнал**:
- Смена режима → изменение стратегии

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Volatility clustering detection, cycle trading

---

### 6.2 STAR (Smooth Transition AR)

**Описание**: Плавные переходы между режимами через логистическую функцию.

**Формула**:
```
yₜ = (φ₀ + Σφᵢyₜ₋ᵢ)·(1-G(sₜ;γ,c)) + (ψ₀ + Σψᵢyₜ₋ᵢ)·G(sₜ;γ,c) + εₜ
G(sₜ;γ,c) = 1/(1 + exp(-γ(sₜ-c)))
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: FX carry trades, gradual cycle shifts

---

### 6.3 LSTAR (Logistic STAR)

**Описание**: STAR с логистической функцией перехода.

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Nonlinear cycle forecasting

---

### 6.4 TAR (Threshold Autoregression)

**Описание**: Общий класс threshold моделей для нелинейных динамик.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Regime-switching по threshold variable

---

### 6.5 TVAR (Threshold VAR)

**Описание**: Многомерная threshold модель для множественных активов.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Multi-asset nonlinear dynamics

---

### 6.6 Smooth Transition VAR (STVAR)

**Описание**: VAR с плавными переходами между режимами.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Multi-asset cycle detection

---

### 6.7 Bilinear Models

**Описание**: Включает квадратичные cross-terms для нелинейных динамик.

**Формула**:
```
yₜ = Σφᵢyₜ₋ᵢ + Σθⱼεₜ₋ⱼ + ΣΣβᵢⱼyₜ₋ᵢεₜ₋ⱼ + εₜ
```

**Применимость**: ★★☆☆☆ (Низкая)
- **Сложность**: Высокая
- **Использование**: High-freq nonlinear returns

---

### 6.8 NARX (Nonlinear AR with eXogenous inputs)

**Описание**: Нелинейная авторегрессия с экзогенными переменными.

**Формула**:
```
yₜ = f(yₜ₋₁,...,yₜ₋ₚ, x₁ₜ,...,xₖₜ, εₜ)
```

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: ML-based forecasting с макро-данными

---

### 6.9 Nonlinear AR (NAR)

**Описание**: Общий класс нелинейных авторегрессий.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Threshold effects в returns/volatility

---

### 6.10 Nonlinear Impulse Response Functions

**Описание**: Regime-dependent шоки в VAR для policy impact trading.

**Применимость**: ★★☆☆☆ (Низкая)
- **Использование**: Macro policy trading

---

## 7. Байесовские методы

### 7.1 Bayesian VAR (BVAR)

**Описание**: VAR с байесовскими priors (Minnesota prior) для shrinkage.

**Формула**:
```
yₜ = Φ₁yₜ₋₁ + ... + Φₚyₜ₋ₚ + εₜ
Prior: Φᵢ ~ N(μprior, Σprior)
```

**Применимость**: ★★★★☆ (Хорошая)
- **Преимущества**: Регуляризация в high-dimensional прогнозах
- **Использование**: Macro forecasting

---

### 7.2 Bayesian Structural Time Series (BSTS)

**Описание**: State-space модель с priors для trend + seasonal + regression components.

**Формула**:
```
yₜ = μₜ + τₜ + βᵀxₜ + εₜ
μₜ = μₜ₋₁ + δₜ₋₁ + ηₜ
δₜ = δₜ₋₁ + ζₜ
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Decomposition, causal impact analysis

---

### 7.3 Bayesian Time Series

**Описание**: Общий класс байесовских методов для временных рядов.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Uncertainty quantification, posterior inference

---

### 7.4 Dirichlet Process Mixtures (DPM)

**Описание**: Непараметрические кластеры состояний для infinite HMM.

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Автоматическое определение числа кластеров
- **Использование**: Regime clustering

---

### 7.5 Gaussian Processes (GP)

**Описание**: Nonparametric regression с kernel для smooth forecasting.

**Формула**:
```
f(x) ~ GP(μ(x), k(x,x'))
```
где k(x,x') - kernel function

**Сигнал**:
- Прогноз: μ* = K*ᵀK⁻¹y
- Uncertainty: σ²* = K** - K*ᵀK⁻¹K*

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Smooth forecasting без фиксированного порядка, uncertainty-aware trading

---

## 8. Спектральный анализ

### 8.1 Periodogram & Fourier Analysis

**Описание**: Спектральный анализ для выявления доминирующих циклов.

**Формула**:
```
I(ωⱼ) = (1/n)|Σₜ yₜ·exp(-iωⱼt)|²
```

**Сигнал**:
- Пики на частотах → циклы
- Торговать в фазе цикла

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Cycle identification (3-5-21 дней), seasonal patterns

---

### 8.2 Wavelet Transforms / Wavelet Coherence

**Описание**: Мультиразрешение анализ для локальных паттернов и корреляций.

**Формула**:
```
W(a,b) = ∫ y(t)·ψ*((t-b)/a) dt
```
где a - scale, b - position

**Сигнал**:
- Высокая coherence между активами на определенном scale → lead-lag

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Lead-lag на разных таймфреймах, multi-resolution patterns

---

### 8.3 Spectral Analysis

**Описание**: Общий класс спектральных методов для частотного анализа.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Frequency domain trading

---

### 8.4 Hilbert-Huang Transform

**Описание**: Instantaneous frequency/amplitude для non-stationary cycle trading.

**Компоненты**:
- Empirical Mode Decomposition (EMD)
- Hilbert Spectral Analysis

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Adaptive cycle extraction

---

### 8.5 Empirical Mode Decomposition (EMD)

**Описание**: Адаптивная декомпозиция на Intrinsic Mode Functions (IMF).

**Процесс**:
1. Находим локальные экстремумы
2. Интерполируем envelope
3. Извлекаем IMF = signal - mean(envelopes)

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Denoising, trend extraction

---

### 8.6 Hurst Exponent

**Описание**: Тест на long-memory и тип процесса.

**Формула**:
```
H = log(R/S) / log(n)
```
где R/S - rescaled range

**Детальный расчет на реальных данных**:

**Пример: S&P 500 Index - R/S Analysis для расчета Hurst Exponent**

1. **Подготовка данных**:
   - Дневные доходности за 1024 дня
   - Returns: r = [0.005, -0.003, 0.008, -0.002, ...]

2. **R/S Analysis для сегмента длины n=256**:

   **Шаг 1: Разделение на сегменты**:
   - Сегмент 1: дни 1-256
   - Сегмент 2: дни 257-512
   - Сегмент 3: дни 513-768
   - Сегмент 4: дни 769-1024

   **Шаг 2: Расчет для сегмента 1 (n=256)**:
   - Среднее: μ = (1/256) × Σrᵢ = 0.0008
   - Отклонения: yᵢ = rᵢ - μ
   - y = [0.0042, -0.0038, 0.0072, -0.0028, ...]
   
   - Кумулятивные отклонения:
     - Y₁ = y₁ = 0.0042
     - Y₂ = y₁ + y₂ = 0.0042 - 0.0038 = 0.0004
     - Y₃ = Y₂ + y₃ = 0.0004 + 0.0072 = 0.0076
     - Y₄ = Y₃ + y₄ = 0.0076 - 0.0028 = 0.0048
     - ... (продолжаем до Y₂₅₆)
   
   - Range: R = max(Y₁, Y₂, ..., Y₂₅₆) - min(Y₁, Y₂, ..., Y₂₅₆)
   - R = 0.125 - (-0.089) = 0.214
   
   - Standard deviation: S = √[(1/n) × Σ(rᵢ - μ)²] = 0.0156
   
   - Rescaled Range: R/S = 0.214 / 0.0156 = 13.72

3. **Повторение для разных n**:
   - n = 64: R/S = 6.8
   - n = 128: R/S = 9.5
   - n = 256: R/S = 13.72
   - n = 512: R/S = 19.3
   - n = 1024: R/S = 27.1

4. **Регрессия log(R/S) на log(n)**:
   - log(64) = 4.16, log(6.8) = 1.92
   - log(128) = 4.85, log(9.5) = 2.25
   - log(256) = 5.55, log(13.72) = 2.62
   - log(512) = 6.24, log(19.3) = 2.96
   - log(1024) = 6.93, log(27.1) = 3.30
   
   Линейная регрессия: log(R/S) = a + H × log(n)
   - Наклон H = 0.58
   - R² = 0.96 (высокая линейность)

5. **Интерпретация**:
   - H = 0.58 > 0.5 → **Trending behavior (persistence)**
   - Прошлые движения имеют влияние на будущие
   - **Стратегия**: Trend-following (momentum)
     - Использовать moving averages
     - Следовать тренду
     - Избегать mean-reversion стратегий

6. **Сравнение с другими активами**:
   - **Commodities (Gold)**: H = 0.65 → сильный тренд
   - **FX (EUR/USD)**: H = 0.52 → слабый тренд
   - **Bonds**: H = 0.45 → mean-reversion
   - **Crypto (BTC)**: H = 0.55 → слабый тренд

7. **Торговые сигналы**:
   - **H > 0.6**: 
     - Агрессивный trend-following
     - Использовать: SMA crossover, momentum indicators
     - Избегать: mean-reversion, contrarian strategies
   
   - **H < 0.4**:
     - Mean-reversion стратегии
     - Использовать: pairs trading, stat arb
     - Избегать: momentum strategies
   
   - **H ≈ 0.5**:
     - Random walk
     - Нейтральная стратегия или избегание

**Интерпретация**:
- H > 0.5 → trending, persistence
- H < 0.5 → mean-reverting, anti-persistence
- H = 0.5 → random walk

**Сигнал**:
- H > 0.6 → trend-following strategies
- H < 0.4 → mean-reversion strategies

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Strategy selection filter

---

### 8.7 Detrended Fluctuation Analysis (DFA)

**Описание**: Оценка долгосрочной памяти в non-stationary рядах.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Alternative to Hurst exponent

---

### 8.8 Lyapunov Exponents

**Описание**: Тестирование хаотичности для predictability границ.

**Формула**:
```
λ = lim(t→∞) (1/t)·log(δ(t)/δ₀)
```

**Интерпретация**:
- λ > 0 → chaotic, низкая предсказуемость
- λ = 0 → neutral
- λ < 0 → stable, высокая предсказуемость

**Применимость**: ★★☆☆☆ (Низкая)
- **Использование**: Chaotic markets identification

---

### 8.9 Multifractal Spectrum Analysis

**Описание**: Scaling exponents для turbulence prediction.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Crisis volatility, extreme events

---

## 9. Микроструктура рынка

### 9.1 Hawkes Processes

**Описание**: Самовозбуждающиеся процессы для моделирования clustering в order flow.

**Формула**:
```
λ(t) = μ + Σᵢ:tᵢ<t α·exp(-β(t-tᵢ))
```
где:
- λ(t) - интенсивность событий
- μ - baseline intensity
- α - эффект самовозбуждения
- β - decay rate

**Сигнал**:
- Высокая λ(t) → кластеризация событий → ликвидность

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: HFT liquidity prediction, order flow clustering

---

### 9.2 ACD (Autoregressive Conditional Duration)

**Описание**: Моделирует интервалы между тиками/ордерами.

**Формула**:
```
ψₜ = ω + α·xₜ₋₁ + β·ψₜ₋₁
xₜ = ψₜ·εₜ
```
где xₜ - duration между событиями

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Liquidity prediction, microstructure analysis

---

### 9.3 Duration Models

**Описание**: Общий класс моделей для интервалов между событиями.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: HFT microstructure

---

### 9.4 VWAP/TWAP Regression

**Описание**: Эконометрика транзакционных издержек.

**Формула**:
```
VWAP = Σ(Pᵢ·Vᵢ) / ΣVᵢ
TWAP = ΣPᵢ / n
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Execution optimization, slippage minimization

---

### 9.5 Optimal Execution (Almgren-Chriss)

**Описание**: Минимизация impact costs при крупных ордерах.

**Формула**:
```
min Σ (market_impact + временной_риск)
subject to: Σxₜ = X (total position)
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Large order execution, institutional trading

---

## 10. Риск-менеджмент

### 10.1 Value-at-Risk (VaR)

**Описание**: Максимальная ожидаемая потеря с заданной вероятностью.

**Методы**:
1. Historical VaR: эмпирический квантиль
2. Parametric VaR: предполагаем распределение
3. Monte Carlo VaR: симуляции

**Детальный расчет на реальных данных**:

**Пример: Портфель $1,000,000 - 1-дневный VaR (95%)**

**Метод 1: Historical VaR**

1. **Сбор исторических данных**:
   - 500 дней доходностей портфеля
   - Returns: R = [-0.025, 0.015, -0.008, 0.012, -0.032, ...]

2. **Сортировка доходностей**:
   - От худших к лучшим: [-0.045, -0.038, -0.032, -0.025, ..., 0.042]
   - 5-й процентиль (95% VaR): 25-я худшая доходность = -0.028

3. **Расчет VaR**:
   - VaR_95% = -0.028 × $1,000,000 = -$28,000
   - **Интерпретация**: С вероятностью 95% потери не превысят $28,000 за день

**Метод 2: Parametric VaR (Variance-Covariance)**

1. **Статистики портфеля**:
   - Средняя доходность: μ = 0.0005 (0.05% в день)
   - Стандартное отклонение: σ = 0.018 (1.8% в день)
   - Z-score для 95%: Φ⁻¹(0.05) = -1.645

2. **Расчет VaR**:
   - VaR_95% = -μ - σ × 1.645
   - VaR_95% = -0.0005 - 0.018 × 1.645 = -0.0005 - 0.0296 = -0.0301
   - VaR_95% = -0.0301 × $1,000,000 = -$30,100

3. **Сравнение с Historical**:
   - Parametric: $30,100
   - Historical: $28,000
   - Разница: Parametric более консервативен (предполагает нормальность)

**Метод 3: Monte Carlo VaR**

1. **Модель ценообразования**:
   - Geometric Brownian Motion: dS = μ·S·dt + σ·S·dW
   - Параметры: μ = 0.0005, σ = 0.018

2. **Симуляция 10,000 сценариев**:
   - Для каждого сценария:
     - Генерируем случайный шок: ε ~ N(0,1)
     - Доходность: R = μ + σ × ε
     - Потеря: Loss = -R × Portfolio_Value
   
   Примеры симуляций:
   - Сценарий 1: ε = -1.8 → R = 0.0005 - 0.018×1.8 = -0.0319 → Loss = $31,900
   - Сценарий 2: ε = 0.5 → R = 0.0005 + 0.018×0.5 = 0.0095 → Loss = -$9,500 (прибыль)
   - ... (10,000 сценариев)

3. **Распределение потерь**:
   - Сортируем потери: [Loss₁, Loss₂, ..., Loss₁₀₀₀₀]
   - 5-й процентиль: Loss₅₀₀ = $29,500
   - VaR_95% = $29,500

4. **Сравнение всех методов**:
   - Historical: $28,000
   - Parametric: $30,100
   - Monte Carlo: $29,500
   - **Среднее**: $29,200

5. **Применение в риск-менеджменте**:
   - **Position Limits**: Максимальная позиция = VaR / (target_VaR_per_position)
     - Если target_VaR = $10,000 на позицию:
     - Максимум позиций = $30,100 / $10,000 = 3 позиции
   
   - **Risk Budgeting**: Распределение VaR между активами
     - Asset 1: VaR = $12,000 (40%)
     - Asset 2: VaR = $10,000 (33%)
     - Asset 3: VaR = $8,100 (27%)

**Формула (Parametric)**:
```
VaR_α = -μ - σ·Φ⁻¹(α)
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Position limits, risk budgeting, stress testing

---

### 10.2 Expected Shortfall (ES/CVaR)

**Описание**: Средняя потеря за пределами VaR (tail risk).

**Формула**:
```
ES_α = E[Loss | Loss > VaR_α]
```

**Применимость**: ★★★★★ (Высокая)
- **Преимущества**: Coherent risk measure в отличие от VaR
- **Использование**: Portfolio hedging, tail risk management

---

### 10.3 Kelly Criterion

**Описание**: Оптимальный размер позиции для максимизации долгосрочного роста.

**Формула**:
```
f* = (p·b - q) / b
```
где:
- p - вероятность выигрыша
- q = 1-p - вероятность проигрыша
- b - odds (отношение выигрыша к проигрышу)

**Детальный расчет на реальных данных**:

**Пример: Торговая стратегия - Kelly Criterion для position sizing**

1. **Сбор статистики за 100 сделок**:
   - Выигрышных сделок: 60 (p = 0.60 = 60%)
   - Проигрышных сделок: 40 (q = 0.40 = 40%)
   - Средний выигрыш: $500
   - Средний проигрыш: $300
   - Капитал: $100,000

2. **Расчет win/loss ratio (b)**:
   - b = Average Win / Average Loss = $500 / $300 = 1.67
   - **Интерпретация**: В среднем выигрыш в 1.67 раз больше проигрыша

3. **Расчет оптимальной доли Kelly**:
   - f* = (p × b - q) / b
   - f* = (0.60 × 1.67 - 0.40) / 1.67
   - f* = (1.002 - 0.40) / 1.67
   - f* = 0.602 / 1.67 = 0.3606 ≈ 36.06%
   
   **Вывод**: Оптимально рисковать 36.06% капитала на каждую сделку

4. **Размер позиции**:
   - Position Size = f* × Capital = 0.3606 × $100,000 = $36,060
   - **Интерпретация**: На каждую сделку выделяем $36,060

5. **Fractional Kelly (более консервативный подход)**:
   - **Half-Kelly**: f_half = f* / 2 = 0.3606 / 2 = 0.1803 = 18.03%
     - Position Size = $18,030
     - Снижает волатильность на ~50%
   
   - **Quarter-Kelly**: f_quarter = f* / 4 = 0.3606 / 4 = 0.0902 = 9.02%
     - Position Size = $9,020
     - Еще более консервативный подход

6. **Ожидаемый рост капитала**:
   - Полный Kelly: E[log(W)] = p × log(1 + f* × b) + q × log(1 - f*)
   - E[log(W)] = 0.60 × log(1 + 0.3606 × 1.67) + 0.40 × log(1 - 0.3606)
   - E[log(W)] = 0.60 × log(1.602) + 0.40 × log(0.6394)
   - E[log(W)] = 0.60 × 0.471 + 0.40 × (-0.447) = 0.283 - 0.179 = 0.104
   - **Ожидаемый логарифмический рост**: 0.104 на сделку (10.4%)

7. **Сравнение с фиксированным размером**:
   - Фиксированный 10%: E[log(W)] = 0.60 × log(1.167) + 0.40 × log(0.9) = 0.029
   - Kelly 36%: E[log(W)] = 0.104
   - **Kelly в 3.6 раз лучше!**

8. **Риск разорения (Risk of Ruin)**:
   - При полном Kelly: вероятность разорения выше
   - При Half-Kelly: значительно ниже риск разорения
   - **Рекомендация**: Использовать Half-Kelly или Quarter-Kelly

9. **Адаптация Kelly с учетом корреляции**:
   - Если несколько позиций коррелированы:
     - f_adj = f* / (1 + ρ × (n-1))
     - где ρ - средняя корреляция, n - число позиций
   - Пример: 3 позиции, ρ = 0.3
     - f_adj = 0.3606 / (1 + 0.3 × 2) = 0.3606 / 1.6 = 0.225 = 22.5%

10. **Применение в реальной торговле**:
    - **Динамическое обновление**: Пересчитывать p, b каждые 50 сделок
    - **Регуляризация**: Использовать Half-Kelly для снижения волатильности
    - **Ограничения**: Максимальный размер позиции = min(f*, max_position_limit)

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Position sizing, capital allocation
- **Примечание**: Обычно используют fractional Kelly (f*/2) для снижения волатильности

---

## 11. Многомерные методы (VAR, VECM)

### 11.1 VAR (Vector Autoregression)

**Описание**: Многомерная авторегрессия для множественных взаимосвязанных временных рядов.

**Формула**:
```
yₜ = Φ₁yₜ₋₁ + ... + Φₚyₜ₋ₚ + εₜ
```
где yₜ - вектор переменных

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Multi-asset forecasting, Granger causality tests

---

### 11.2 VARX (VAR with eXogenous variables)

**Описание**: VAR с экзогенными переменными (макро-данные).

**Формула**:
```
yₜ = Φ₁yₜ₋₁ + ... + Φₚyₜ₋ₚ + Β·xₜ + εₜ
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Macro data incorporation, cross-market causality

---

### 11.3 VECM (Vector Error Correction Model)

**Описание**: VAR для коинтегрированных рядов с error correction term.

**Формула**:
```
Δyₜ = Π·yₜ₋₁ + Σᵢ Γᵢ·Δyₜ₋ᵢ + εₜ
Π = α·β'
```
где β - коинтеграционные векторы, α - скорость adjustment

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Multi-asset cointegration, long-term equilibrium

---

### 11.4 TVP-VAR (Time-Varying Parameter VAR)

**Описание**: VAR с динамическими коэффициентами для меняющихся связей.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Crisis dynamics, changing asset relationships

---

### 11.5 Multivariate Stochastic Volatility

**Описание**: Совместное моделирование волатильностей и корреляций.

**Применимость**: ★★★☆☆ (Средняя)
- **Сложность**: Очень высокая вычислительная
- **Использование**: Multi-asset hedging

---

### 11.6 Multivariate GARCH (не DCC)

**Описание**: Общий класс многомерных GARCH моделей (BEKK, VECH).

**Применимость**: ★★★☆☆ (Средняя)
- **Недостатки**: Curse of dimensionality
- **Использование**: 2-3 asset volatility modeling

---

## 12. Стохастические процессы

### 12.1 Ornstein-Uhlenbeck (OU) Process

**Описание**: Процесс с mean-reversion для моделирования spreads.

**Формула (SDE)**:
```
dx = θ·(μ - x)·dt + σ·dW
```
где:
- θ - скорость mean-reversion
- μ - long-term mean
- σ - волатильность

**Детальный расчет на реальных данных**:

**Пример: Spread между GLD и SLV - OU Process**

1. **Оценка параметров из исторических данных**:
   - Spread данные: x = [0.5, -1.2, 2.3, -0.8, 1.5, ...]
   - AR(1) модель: xₜ = c + φ × xₜ₋₁ + εₜ
   - Оценки: c = 0.1, φ = 0.85
   - Преобразование: μ = c / (1 - φ) = 0.1 / 0.15 = 0.667
   - θ = -ln(φ) / Δt = -ln(0.85) / 1 = 0.1625 (при Δt = 1 день)
   - σ² = Var(ε) / (1 - φ²) = 0.5 / (1 - 0.7225) = 1.80
   - σ = 1.34

2. **Расчет Half-life**:
   - τ = ln(2) / θ = 0.693 / 0.1625 = 4.26 дня
   - **Интерпретация**: Spread вернется на половину пути к среднему за 4.26 дня

3. **Пошаговый расчет прогноза**:

   День t (текущий):
   - xₜ = 2.5 (spread выше среднего)
   - μ = 0.667, θ = 0.1625, σ = 1.34
   
   Прогноз на t+1:
   - xₜ₊₁ = μ + exp(-θ × Δt) × (xₜ - μ) + εₜ₊₁
   - xₜ₊₁ = 0.667 + exp(-0.1625 × 1) × (2.5 - 0.667) + εₜ₊₁
   - xₜ₊₁ = 0.667 + 0.850 × 1.833 + εₜ₊₁
   - xₜ₊₁ = 0.667 + 1.558 + εₜ₊₁ = 2.225 + εₜ₊₁
   - E[xₜ₊₁] = 2.225 (ожидаемое значение)
   
   **Вывод**: Spread уменьшится с 2.5 до ~2.2 (mean-reversion работает)

4. **Вероятностные границы**:
   - 95% доверительный интервал: xₜ₊₁ ∈ [E[xₜ₊₁] ± 1.96 × σ]
   - xₜ₊₁ ∈ [2.225 - 1.96 × 1.34, 2.225 + 1.96 × 1.34]
   - xₜ₊₁ ∈ [-0.40, 4.85]

5. **Торговые сигналы**:
   - **Вход Long**: xₜ < μ - 2σ = 0.667 - 2 × 1.34 = -2.01
     - Spread слишком низкий → ожидается рост
     - Действие: Long spread (buy GLD, sell SLV)
   
   - **Вход Short**: xₜ > μ + 2σ = 0.667 + 2 × 1.34 = 3.35
     - Spread слишком высокий → ожидается падение
     - Действие: Short spread (sell GLD, buy SLV)
   
   - **Выход**: |xₜ - μ| < 0.5 × σ = 0.67
     - Spread вернулся к среднему → закрыть позицию

6. **Пример торговли**:
   - День 1: x₁ = 3.8 > 3.35 → **Short spread**
     - Продать GLD: -1 × $180 = -$180
     - Купить SLV: +7.15 × $25 = +$178.75
     - Net: -$1.25
   
   - День 5 (через half-life):
     - Ожидаемый spread: x₅ ≈ μ + (x₁ - μ) × exp(-θ × 4) = 0.667 + 3.133 × 0.52 = 2.30
     - Фактический: x₅ = 2.1
     - **Закрыть позицию** (прибыль ~$1.65)

**Дискретная версия**:
```
xₜ = μ + exp(-θ·Δt)·(xₜ₋₁ - μ) + εₜ
```

**Half-life**:
```
τ = ln(2) / θ
```

**Сигнал**:
- x > μ + 2σ → Short (возврат к среднему)
- x < μ - 2σ → Long

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Pairs trading, stat arb, оптимальный entry timing

---

### 12.2 Lévy Processes

**Описание**: Процессы с jumps для моделирования экстремальных событий.

**Типы**:
- Poisson jumps
- Variance Gamma
- Normal Inverse Gaussian

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Option pricing, jump risk modeling

---

### 12.3 Stochastic Processes (общие)

**Описание**: Общий класс стохастических процессов.

**Применимость**: ★★★☆☆ (Средняя)

---

### 12.4 Stochastic Volatility Models

**Описание**: Волатильность сама является стохастическим процессом.

**Формула (Heston)**:
```
dS = μ·S·dt + √V·S·dW₁
dV = κ·(θ - V)·dt + σᵥ·√V·dW₂
```

**Применимость**: ★★★☆☆ (Средняя)
- **Сложность**: Высокая
- **Использование**: Option pricing, volatility trading

---

## 13. Машинное обучение для временных рядов

### 13.1 Kalman Filters

**Описание**: Оптимальная фильтрация для state-space моделей.

**Формулы**:
**Predict**:
```
x̂ₜ|ₜ₋₁ = F·x̂ₜ₋₁|ₜ₋₁
Pₜ|ₜ₋₁ = F·Pₜ₋₁|ₜ₋₁·F' + Q
```

**Update**:
```
Kₜ = Pₜ|ₜ₋₁·H'·(H·Pₜ|ₜ₋₁·H' + R)⁻¹
x̂ₜ|ₜ = x̂ₜ|ₜ₋₁ + Kₜ·(yₜ - H·x̂ₜ|ₜ₋₁)
Pₜ|ₜ = (I - Kₜ·H)·Pₜ|ₜ₋₁
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Adaptive hedge ratios, trend filtering, noise reduction

---

### 13.2 Particle Filter (Sequential Monte Carlo)

**Описание**: Online state estimation для nonlinear/non-Gaussian систем.

**Применимость**: ★★★☆☆ (Средняя)
- **Преимущества**: Работает с нелинейными системами
- **Использование**: Nonlinear state estimation

---

### 13.3 Score-Driven Models (GAS)

**Описание**: Динамическое обновление параметров по score function.

**Формула**:
```
θₜ = ω + α·sₜ₋₁ + β·θₜ₋₁
sₜ = S·∇log f(yₜ|θₜ)
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Adaptive volatility/correlation, turbulent markets

---

### 13.4 Sieve Estimation / Sieve Methods

**Описание**: Basis expansion (splines/Fourier) для nonparametric conditional mean/volatility.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Flexible functional forms

---

### 13.5 Random Matrix Theory (RMT)

**Описание**: Noise filtering в correlation matrices по Marchenko-Pastur закону.

**Формула**:
```
λ_max/min = σ²·(1 ± √(N/T))²
```
Собственные значения вне границ - signal, внутри - noise

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Clean factors extraction, correlation matrix denoising

---

### 13.6 Principal Oscillation Patterns (POP)

**Описание**: Oscillating modes в multivariate TS для cycle extraction.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Multi-asset cycle trading

---

### 13.7 Local Projections

**Описание**: Direct h-step forecasts без VAR recursion.

**Формула**:
```
yₜ₊ₕ = α_h + β_h·xₜ + εₜ₊ₕ
```

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Impulse response в policy trading

---

### 13.8 Functional Data Analysis

**Описание**: Анализ функциональных данных (curves, surfaces).

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Yield curve trading, intraday patterns

---

## 14. Дополнительные методы

### 14.1 Probit/Logit Models

**Описание**: Предсказание binary outcomes (направление рынка).

**Формула (Logit)**:
```
P(Y=1|X) = 1 / (1 + exp(-(β₀ + β'X)))
```

**Сигнал**:
- P > 0.6 → Long
- P < 0.4 → Short

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Directional bets, signal filtering, HFT regimes

---

### 14.2 HAR (Heterogeneous Autoregressive)

**Описание**: Захватывает long-memory волатильности через multiple horizons.

**Формула**:
```
RVₜ = β₀ + βd·RVₜ₋₁^(daily) + βw·RVₜ₋₅:ₜ₋₁^(weekly) + βm·RVₜ₋₂₂:ₜ₋₁^(monthly) + εₜ
```

**Детальный расчет на реальных данных**:

**Пример: SPY - HAR модель для прогнозирования волатильности**

1. **Подготовка данных**:
   - 100 дней Realized Volatility (RV)
   - Дневные RV: RV = [0.00085, 0.0012, 0.00065, 0.0015, ...]

2. **Расчет агрегированных RV**:

   **День t (текущий)**:
   - RVₜ₋₁^(daily) = 0.0012 (вчерашняя RV)
   
   - RVₜ₋₅:ₜ₋₁^(weekly) = (1/5) × (RVₜ₋₁ + RVₜ₋₂ + RVₜ₋₃ + RVₜ₋₄ + RVₜ₋₅)
   - RVₜ₋₅:ₜ₋₁ = (1/5) × (0.0012 + 0.00085 + 0.0015 + 0.0009 + 0.0011)
   - RVₜ₋₅:ₜ₋₁ = (1/5) × 0.00555 = 0.00111
   
   - RVₜ₋₂₂:ₜ₋₁^(monthly) = (1/22) × Σᵢ₌₁²² RVₜ₋ᵢ
   - RVₜ₋₂₂:ₜ₋₁ = (1/22) × 0.022 = 0.00100

3. **Оценка параметров HAR модели**:
   - OLS регрессия: RVₜ = β₀ + βd × RVₜ₋₁ + βw × RVₜ₋₅:ₜ₋₁ + βm × RVₜ₋₂₂:ₜ₋₁ + εₜ
   - Оценки:
     - β₀ = 0.0001
     - βd = 0.35 (дневной эффект)
     - βw = 0.40 (недельный эффект)
     - βm = 0.20 (месячный эффект)
   - R² = 0.72 (хорошая объясняющая способность)

4. **Прогноз волатильности на день t+1**:
   - RV̂ₜ₊₁ = 0.0001 + 0.35 × 0.0012 + 0.40 × 0.00111 + 0.20 × 0.00100
   - RV̂ₜ₊₁ = 0.0001 + 0.00042 + 0.000444 + 0.00020 = 0.001164
   - σ̂ₜ₊₁ = √0.001164 = 0.0341 = 3.41% (дневная волатильность)

5. **Интерпретация коэффициентов**:
   - **βd = 0.35**: Вчерашняя волатильность влияет на завтрашнюю (краткосрочная память)
   - **βw = 0.40**: Недельная волатильность имеет наибольший вес (среднесрочная память)
   - **βm = 0.20**: Месячная волатильность влияет слабее (долгосрочная память)
   - **Вывод**: Волатильность имеет долгую память (long-memory)

6. **Сравнение с GARCH**:
   - GARCH(1,1) прогноз: σ_GARCH = 0.028 (2.8%)
   - HAR прогноз: σ_HAR = 0.0341 (3.41%)
   - **HAR выше** → учитывает долгую память волатильности

7. **Применение в торговле**:
   - **Option Pricing**: Использовать HAR прогноз для pricing опционов
   - **VIX Trading**: HAR лучше предсказывает VIX, чем GARCH
   - **Risk Management**: Более точные VaR расчеты
   - **Volatility Trading**: Позиционирование на основе HAR прогноза

8. **Расширения HAR модели**:
   - **HAR-J**: Добавление jump компонента
   - **HAR-RV-J**: Комбинация RV и jumps
   - **HAR-RV-CJ**: Разделение continuous и jump компонентов

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Volatility forecasting, VIX trading, option pricing

---

### 14.3 Realized Semivariances

**Описание**: Directional volatility (upside/downside) из HF данных.

**Формула**:
```
RS⁺ = Σ r²ₜ,ᵢ·I(rₜ,ᵢ>0)
RS⁻ = Σ r²ₜ,ᵢ·I(rₜ,ᵢ<0)
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Asymmetric risk models, tail hedging, volatility arbitrage

---

### 14.4 Panel Data Regression

**Описание**: Cross-section активов по времени для паттернов.

**Формула**:
```
yᵢₜ = α + β·xᵢₜ + uᵢ + εᵢₜ
```

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Momentum/mean-reversion в ETF baskets

---

### 14.5 Granger Causality Tests

**Описание**: Тест направленной причинности между активами.

**Формула**:
```
H₀: β₁ = ... = βₚ = 0 в модели:
yₜ = α + Σφᵢyₜ₋ᵢ + Σβⱼxₜ₋ⱼ + εₜ
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Lead-lag arbitrage (VIX → SPX), cross-market signals

---

### 14.6 ARCH-in-Mean

**Описание**: Включает волатильность в условное среднее.

**Формула**:
```
yₜ = μ + γ·σ²ₜ + εₜ
σ²ₜ = ω + α·ε²ₜ₋₁ + β·σ²ₜ₋₁
```

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Risk-premia harvesting в equity returns

---

### 14.7 Structural Break Tests (Chow, Zivot-Andrews)

**Описание**: Детекция смены режимов/параметров.

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Adaptive modeling, regime change detection

---

### 14.8 Unit Root Tests (ADF, KPSS, Phillips-Perron)

**Описание**: Тесты стационарности для preparation к моделированию.

**ADF Test**:
```
H₀: δ = 0 в модели:
Δyₜ = α + δ·yₜ₋₁ + Σφᵢ·Δyₜ₋ᵢ + εₜ
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: Cointegration prep, stationarity verification

---

### 14.9 Information Criteria (AIC/BIC/HQIC)

**Описание**: Model selection для order determination.

**Формулы**:
```
AIC = -2log(L) + 2k
BIC = -2log(L) + k·log(n)
```

**Применимость**: ★★★★★ (Высокая)
- **Использование**: ARIMA/VAR/GARCH order selection

---

### 14.10 Copula Models

**Описание**: Моделирование зависимостей между маржинальными распределениями.

**Типы**:
- Gaussian Copula
- t-Copula
- Archimedean (Clayton, Gumbel)

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Tail dependence, multi-asset risk

---

### 14.11 Quantile Regression

**Описание**: Регрессия для квантилей распределения (не только среднего).

**Формула**:
```
min Σ ρτ(yᵢ - xᵢ'β)
```
где ρτ(u) = u·(τ - I(u<0))

**Применимость**: ★★★★☆ (Хорошая)
- **Использование**: Tail risk modeling, asymmetric effects

---

### 14.12 Threshold Models (общие)

**Описание**: Общий класс моделей с переключениями по порогам.

**Применимость**: ★★★★☆ (Хорошая)

---

### 14.13 Regime-Switching (общие)

**Описание**: Общий класс моделей со сменой режимов.

**Применимость**: ★★★★☆ (Хорошая)

---

### 14.14 Long Memory Models (общие)

**Описание**: Модели с долгой памятью (ARFIMA, FIGARCH).

**Применимость**: ★★★★☆ (Хорошая)

---

### 14.15 Nonlinear ARCH (общие)

**Описание**: Нелинейные расширения ARCH моделей.

**Применимость**: ★★★☆☆ (Средняя)

---

### 14.16 Chaos Theory

**Описание**: Детерминированный хаос в нелинейных системах.

**Применимость**: ★★☆☆☆ (Низкая)
- **Использование**: Исследовательские стратегии, границы предсказуемости

---

### 14.17 Nonparametric Methods

**Описание**: Методы без параметрических предположений.

**Применимость**: ★★★☆☆ (Средняя)
- **Примеры**: Kernel regression, local polynomial

---

### 14.18 Local Level Models

**Описание**: State-space декомпозиция на trend + cycle + irregular.

**Применимость**: ★★★☆☆ (Средняя)
- **Использование**: Cycle-based signals

---

## Итоговая сводная таблица по применимости

| Категория | Высокая (★★★★★) | Хорошая (★★★★☆) | Средняя (★★★☆☆) |
|-----------|-----------------|-----------------|-----------------|
| **Волатильность** | GARCH, EGARCH, DCC-GARCH, RV | TGARCH, Component GARCH | IGARCH, FIGARCH, NAGARCH, APARCH |
| **Режимы** | HMM | Markov-Switching | MS-VAR, iHMM |
| **Прогнозирование** | ARIMA, ARFIMA | - | Periodic AR |
| **Коинтеграция** | Engle-Granger, Dynamic Coint | Johansen | Fractional Coint |
| **Факторы** | PCA | Fama-French, Carhart, DFM | APT, ICAPM, FPCA |
| **Нелинейные** | - | SETAR, STAR, LSTAR | TAR, TVAR, STVAR, Bilinear, NARX |
| **Байесовские** | - | BVAR, BSTS, GP | DPM |
| **Спектральный** | Hurst Exponent | Periodogram, Wavelets | Hilbert-Huang, EMD, DFA, Lyapunov, Multifractal |
| **Микроструктура** | VWAP/TWAP | Hawkes, ACD, Almgren-Chriss | Duration Models |
| **Риск** | VaR, CVaR, Kelly | - | - |
| **Многомерные** | - | VAR, VARX, VECM | TVP-VAR, Multivariate SV |
| **Стохастические** | OU Process | - | Lévy, SV Models |
| **ML/TS** | Kalman, Unit Root Tests, Information Criteria | Score-Driven, RMT | Particle Filter, Sieve, POP, Local Projections, FDA |
| **Дополнительные** | Granger Causality | Probit/Logit, HAR, Realized Semiv, Panel, Struct Breaks, Quantile Reg | ARCH-in-Mean, Copulas, Chaos |

---

## Приоритеты реализации для нашего проекта

### Фаза 1: Базовые модели (Must-Have)
1. **GARCH семейство**: GARCH, EGARCH, TGARCH
2. **ARIMA семейство**: ARIMA, ARFIMA
3. **Kalman Filter**: Adaptive parameters
4. **OU Process**: Pairs trading
5. **Engle-Granger**: Cointegration
6. **PCA**: Factor extraction
7. **Hurst Exponent**: Strategy selection
8. **VaR/CVaR**: Risk management
9. **Kelly Criterion**: Position sizing
10. **Unit Root Tests**: Stationarity checks

### Фаза 2: Продвинутые модели (Should-Have)
1. **HMM**: Regime detection
2. **DCC-GARCH**: Dynamic correlations
3. **SETAR/STAR**: Nonlinear models
4. **Johansen**: Multi-asset cointegration
5. **VAR/VECM**: Multivariate forecasting
6. **Fama-French/Carhart**: Factor models
7. **HAR**: Volatility forecasting
8. **Hawkes Processes**: Microstructure
9. **BVAR**: Bayesian forecasting
10. **Wavelets**: Multi-resolution analysis

### Фаза 3: Специализированные модели (Nice-to-Have)
1. **GP**: Nonparametric forecasting
2. **Score-Driven**: Adaptive parameters
3. **iHMM**: Automatic regime count
4. **RMT**: Correlation cleaning
5. **Particle Filter**: Nonlinear estimation
6. **Quantile Regression**: Tail modeling
7. **Almgren-Chriss**: Optimal execution

---

## Архитектурные рекомендации для реализации

### 1. Интеграция в существующий Indicator Layer

**ВАЖНО**: Все статистические методы реализуются как индикаторы, а не отдельная система "моделей". Это те же индикаторы, просто со статистическими алгоритмами внутри.

```rust
src/indicators/
├── technical/              // Существующие технические индикаторы
│   ├── sma.rs
│   ├── ema.rs
│   ├── rsi.rs
│   ├── macd.rs
│   ├── bollinger.rs
│   └── mod.rs
│
├── statistical/            // НОВАЯ категория: статистические индикаторы
│   ├── volatility/
│   │   ├── garch.rs        // GARCHIndicator -> Vector (σ²ₜ)
│   │   ├── egarch.rs       // EGARCHIndicator -> Vector (log σ²ₜ)
│   │   ├── tgarch.rs       // TGARCHIndicator -> Vector (σ²ₜ)
│   │   ├── dcc_garch.rs    // DCCGARCHIndicator -> Matrix (Correlations)
│   │   ├── realized_vol.rs // RealizedVolIndicator -> Vector (RV)
│   │   └── mod.rs
│   │
│   ├── forecasting/
│   │   ├── arima.rs        // ARIMAIndicator -> Vector (forecasts)
│   │   ├── arfima.rs       // ARFIMAIndicator -> Vector (forecasts)
│   │   ├── var.rs          // VARIndicator -> Matrix (multi-asset forecasts)
│   │   ├── vecm.rs         // VECMIndicator -> Matrix
│   │   ├── kalman.rs       // KalmanFilterIndicator -> Vector (filtered values)
│   │   └── mod.rs
│   │
│   ├── regimes/
│   │   ├── hmm.rs          // HMMIndicator -> Vector (regime probabilities)
│   │   ├── markov_switching.rs // MarkovSwitchingIndicator
│   │   └── mod.rs
│   │
│   ├── cointegration/
│   │   ├── spread.rs       // CointegrationSpreadIndicator -> Vector (spread)
│   │   ├── ou_process.rs   // OUProcessIndicator -> Vector (mean-reversion signal)
│   │   ├── zscore.rs       // ZScoreIndicator -> Vector (z-score of spread)
│   │   └── mod.rs
│   │
│   ├── factors/
│   │   ├── pca.rs          // PCAIndicator -> Matrix (principal components)
│   │   ├── fama_french.rs  // FamaFrenchIndicator -> Vector (factor loadings)
│   │   └── mod.rs
│   │
│   ├── nonlinear/
│   │   ├── setar.rs        // SETARIndicator -> Vector (regime-based forecast)
│   │   ├── star.rs         // STARIndicator -> Vector (smooth regime forecast)
│   │   └── mod.rs
│   │
│   ├── spectral/
│   │   ├── hurst.rs        // HurstExponentIndicator -> Scalar (H value)
│   │   ├── wavelet.rs      // WaveletIndicator -> Matrix (decomposition)
│   │   ├── periodogram.rs  // PeriodogramIndicator -> Vector (spectrum)
│   │   └── mod.rs
│   │
│   ├── tests/
│   │   ├── unit_root.rs    // ADFTestIndicator -> Scalar (test statistic)
│   │   ├── granger.rs      // GrangerCausalityIndicator -> Scalar (F-stat)
│   │   ├── cointegration_test.rs // JohansenTestIndicator
│   │   └── mod.rs
│   │
│   └── mod.rs
│
├── risk/                   // Риск-метрики как индикаторы
│   ├── var.rs              // VaRIndicator -> Scalar (VaR value)
│   ├── cvar.rs             // CVaRIndicator -> Scalar (CVaR value)
│   ├── kelly.rs            // KellyCriterionIndicator -> Scalar (optimal f)
│   ├── sharpe.rs           // SharpeRatioIndicator -> Scalar
│   └── mod.rs
│
├── ml/                     // ML-based индикаторы (будущее)
│   ├── gaussian_process.rs // GPIndicator
│   ├── particle_filter.rs  // ParticleFilterIndicator
│   └── mod.rs
│
├── base.rs                 // Trait Indicator
├── registry.rs             // Registry для всех индикаторов
├── factory.rs              // Factory для создания индикаторов
├── execution_engine.rs     // DAG execution engine
└── mod.rs
```

### 2. Единый интерфейс Indicator

Все статистические методы имплементируют существующий trait:

```rust
// src/indicators/base.rs
pub trait Indicator: Send + Sync {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult>;
    fn parameters(&self) -> &Parameters;
    fn name(&self) -> &str;
    fn dependencies(&self) -> Vec<String>;
}

pub enum IndicatorResult {
    Scalar(f64),           // Одно значение (Hurst, VaR)
    Vector(Vector),        // Временной ряд (GARCH, ARIMA)
    Matrix(Matrix),        // Многомерные (PCA, DCC-GARCH)
}
```

**Примеры реализации**:

```rust
// Простой индикатор: SMA
pub struct SMAIndicator {
    period: usize,
}

impl Indicator for SMAIndicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        let result = data.close.rolling_mean(self.period)?;
        Ok(IndicatorResult::Vector(result))
    }
}

// Статистический индикатор: GARCH (сложнее, но тот же интерфейс!)
pub struct GARCHIndicator {
    omega: f64,
    alpha: f64,
    beta: f64,
    history: VecDeque<f64>,
}

impl Indicator for GARCHIndicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        let returns = data.close.pct_change()?;
        let sigma2 = self.estimate_conditional_variance(&returns)?;
        Ok(IndicatorResult::Vector(sigma2))
    }
}

impl GARCHIndicator {
    fn estimate_conditional_variance(&mut self, returns: &Vector) -> Result<Vector> {
        let mut sigma2 = Vec::with_capacity(returns.len());
        let mut current_sigma2 = self.omega / (1.0 - self.alpha - self.beta);
        
        for &r in returns.iter() {
            current_sigma2 = self.omega + self.alpha * r.powi(2) + self.beta * current_sigma2;
            sigma2.push(current_sigma2);
        }
        
        Ok(Vector::from(sigma2))
    }
}

// Тестовый индикатор: Hurst Exponent
pub struct HurstExponentIndicator {
    window: usize,
}

impl Indicator for HurstExponentIndicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        let h = self.calculate_hurst(&data.close)?;
        Ok(IndicatorResult::Scalar(h))
    }
}

// Многомерный индикатор: PCA
pub struct PCAIndicator {
    n_components: usize,
    assets: Vec<String>,
}

impl Indicator for PCAIndicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        let components = self.fit_transform(data)?;
        Ok(IndicatorResult::Matrix(components))
    }
}
```

### 3. Регистрация в единой системе

```rust
// src/indicators/registry.rs
impl IndicatorRegistry {
    pub fn register_all() -> Self {
        let mut registry = Self::new();
        
        // Технические индикаторы (уже есть)
        registry.register("SMA", Box::new(SMAIndicator::new));
        registry.register("EMA", Box::new(EMAIndicator::new));
        registry.register("RSI", Box::new(RSIIndicator::new));
        
        // Статистические индикаторы (НОВЫЕ)
        registry.register("GARCH", Box::new(GARCHIndicator::new));
        registry.register("EGARCH", Box::new(EGARCHIndicator::new));
        registry.register("ARIMA", Box::new(ARIMAIndicator::new));
        registry.register("HMM", Box::new(HMMIndicator::new));
        registry.register("OU_SPREAD", Box::new(OUProcessIndicator::new));
        registry.register("HURST", Box::new(HurstExponentIndicator::new));
        registry.register("PCA", Box::new(PCAIndicator::new));
        registry.register("VAR_RISK", Box::new(VaRIndicator::new));
        registry.register("KELLY", Box::new(KellyCriterionIndicator::new));
        
        // Тесты как индикаторы
        registry.register("ADF_TEST", Box::new(ADFTestIndicator::new));
        registry.register("GRANGER", Box::new(GrangerCausalityIndicator::new));
        
        registry
    }
}
```

### 4. Использование в Strategy Discovery

```rust
// Strategy Discovery автоматически комбинирует ВСЕ индикаторы
pub struct StrategyDiscovery {
    registry: IndicatorRegistry,
}

impl StrategyDiscovery {
    pub fn generate_combinations(&self) -> Vec<StrategyCandidate> {
        let indicators = self.registry.list_all();
        
        // Комбинируем технические + статистические
        let combinations = vec![
            // Классика
            vec!["SMA(50)", "SMA(200)", "Crossover"],
            
            // Технический + Статистический
            vec!["RSI(14)", "GARCH", "VolatilityFilter"],
            vec!["MACD", "HURST", "TrendFilter"],
            
            // Полностью статистический
            vec!["ARIMA(2,1,2)", "GARCH", "ForecastGARCH"],
            vec!["OU_SPREAD", "ADF_TEST", "PairsTrade"],
            vec!["HMM", "GARCH", "RegimeVolatility"],
            
            // Мультиактивные
            vec!["PCA", "FAMA_FRENCH", "FactorRotation"],
            
            // С риск-менеджментом
            vec!["SMA(50)", "GARCH", "VAR_RISK", "KELLY"],
        ];
        
        combinations.into_iter()
            .map(|combo| self.build_strategy(combo))
            .collect()
    }
}
```

### 5. Execution Engine с DAG

```rust
// Execution Engine уже умеет строить DAG - используем его!
let strategy_dag = vec![
    // Вычисляем волатильность
    ("vol", "GARCH", params![omega: 0.01, alpha: 0.1, beta: 0.8]),
    
    // Вычисляем прогноз
    ("forecast", "ARIMA", params![p: 2, d: 1, q: 2]),
    
    // Проверяем режим
    ("regime", "HMM", params![n_states: 3]),
    
    // Фильтруем по волатильности
    ("vol_ok", "LT", params![a: "vol", threshold: 0.02]),
    
    // Фильтруем по режиму (бычий рынок)
    ("bullish", "EQ", params![a: "regime", value: 2]),
    
    // Генерируем сигнал
    ("signal", "AND", params![conditions: vec!["forecast>0", "vol_ok", "bullish"]]),
    
    // Размер позиции по Kelly
    ("position_size", "KELLY", params![
        win_rate: "historical_win_rate",
        avg_win: "avg_win",
        avg_loss: "avg_loss"
    ]),
];

engine.execute_dag(&strategy_dag, &data)?;
```

### 6. Производительность
- **SIMD**: Векторизация матричных операций (ndarray + rayon)
- **GPU**: CUDA для тяжелых вычислений (HMM, Particle Filter)
- **Кэширование**: Мемоизация likelihood вычислений в индикаторах
- **Параллелизм**: Rayon для независимых вычислений в DAG
- **Инкрементальные обновления**: Индикаторы могут поддерживать incremental calculation

### 7. Интеграция со всеми слоями системы

```rust
// ============================================
// INDICATOR LAYER - Все статистические методы здесь
// ============================================
pub trait Indicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult>;
}

// ============================================
// CONDITION LAYER - Использует индикаторы
// ============================================
pub struct VolatilityCondition {
    garch: GARCHIndicator,
    threshold: f64,
}

impl Condition for VolatilityCondition {
    fn evaluate(&mut self, data: &QuoteFrame) -> Result<bool> {
        let vol = self.garch.calculate(data)?;
        Ok(vol.last() < self.threshold)
    }
}

pub struct RegimeCondition {
    hmm: HMMIndicator,
    target_regime: usize,
}

impl Condition for RegimeCondition {
    fn evaluate(&mut self, data: &QuoteFrame) -> Result<bool> {
        let regime = self.hmm.calculate(data)?;
        Ok(regime.most_likely() == self.target_regime)
    }
}

// ============================================
// STRATEGY LAYER - Комбинирует всё
// ============================================
pub struct StatisticalStrategy {
    // Индикаторы для анализа
    forecast: ARIMAIndicator,
    volatility: GARCHIndicator,
    regime: HMMIndicator,
    
    // Условия входа/выхода
    entry_conditions: Vec<Box<dyn Condition>>,
    exit_conditions: Vec<Box<dyn Condition>>,
}

impl Strategy for StatisticalStrategy {
    fn generate_signals(&mut self, data: &QuoteFrame) -> Result<Signal> {
        // Вычисляем индикаторы
        let forecast = self.forecast.calculate(data)?;
        let vol = self.volatility.calculate(data)?;
        let regime = self.regime.calculate(data)?;
        
        // Проверяем условия
        let should_enter = self.entry_conditions.iter()
            .all(|c| c.evaluate(data).unwrap_or(false));
        
        if should_enter {
            Ok(Signal::Long)
        } else {
            Ok(Signal::Flat)
        }
    }
}

// ============================================
// RISK MANAGEMENT LAYER - Использует risk индикаторы
// ============================================
pub struct RiskManager {
    var: VaRIndicator,
    cvar: CVaRIndicator,
    kelly: KellyCriterionIndicator,
}

impl RiskManager {
    pub fn calculate_position_size(&mut self, data: &QuoteFrame) -> Result<f64> {
        // VaR для лимитов
        let var = self.var.calculate(data)?;
        
        // Kelly для оптимального размера
        let optimal_f = self.kelly.calculate(data)?;
        
        // CVaR для tail risk
        let cvar = self.cvar.calculate(data)?;
        
        // Комбинируем
        let size = optimal_f.min(self.max_size_by_var(var?));
        Ok(size)
    }
}

// ============================================
// OPTIMIZATION LAYER - Оптимизирует параметры индикаторов
// ============================================
pub struct Optimizer {
    search_space: SearchSpace,
}

impl Optimizer {
    pub fn optimize_statistical_strategy(&self) -> Result<OptimalParameters> {
        // Оптимизируем параметры всех индикаторов
        let search_space = SearchSpace {
            indicators: vec![
                ("GARCH", params![
                    omega: Range(0.001, 0.1),
                    alpha: Range(0.01, 0.3),
                    beta: Range(0.5, 0.95),
                ]),
                ("ARIMA", params![
                    p: Discrete(vec![1, 2, 3, 4]),
                    d: Discrete(vec![0, 1, 2]),
                    q: Discrete(vec![1, 2, 3, 4]),
                ]),
                ("HMM", params![
                    n_states: Discrete(vec![2, 3, 4]),
                ]),
            ],
        };
        
        self.genetic_algorithm.optimize(search_space)
    }
}

// ============================================
// STRATEGY DISCOVERY - Автоматическая генерация
// ============================================
pub struct StrategyDiscovery {
    registry: IndicatorRegistry,
    condition_builder: ConditionBuilder,
}

impl StrategyDiscovery {
    pub fn discover_strategies(&self) -> Vec<Strategy> {
        let all_indicators = self.registry.list_all();
        
        // Генерируем все возможные комбинации
        let combinations = self.generate_combinations(all_indicators);
        
        combinations.into_iter()
            .filter_map(|combo| self.build_strategy(combo))
            .collect()
    }
    
    fn generate_combinations(&self, indicators: Vec<String>) -> Vec<Vec<String>> {
        // Пример: комбинируем 2-4 индикатора
        let mut combinations = Vec::new();
        
        // Двухиндикаторные стратегии
        for i in &indicators {
            for j in &indicators {
                if i != j {
                    combinations.push(vec![i.clone(), j.clone()]);
                }
            }
        }
        
        // Трехиндикаторные с условиями
        for i in &indicators {
            for j in &indicators {
                for k in &indicators {
                    if i != j && j != k && i != k {
                        combinations.push(vec![i.clone(), j.clone(), k.clone()]);
                    }
                }
            }
        }
        
        combinations
    }
}
```

### 8. Data Pipeline - Единый поток

```
┌──────────────┐
│  ClickHouse  │ (L3 - холодное хранилище)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│    Redis     │ (L1 - горячий кэш)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│    Arrow     │ (L2 - in-memory вычисления)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  QuoteFrame  │ (Unified data structure)
└──────┬───────┘
       │
       ├──────────────────────────────────┐
       │                                  │
       ▼                                  ▼
┌──────────────────┐            ┌──────────────────┐
│ Technical Inds   │            │ Statistical Inds │
│ - SMA            │            │ - GARCH          │
│ - RSI            │            │ - ARIMA          │
│ - MACD           │            │ - HMM            │
└────────┬─────────┘            └────────┬─────────┘
         │                               │
         └───────────┬───────────────────┘
                     │
                     ▼
            ┌────────────────┐
            │ Condition Layer│
            │ - Filters      │
            │ - Regime Checks│
            └────────┬───────┘
                     │
                     ▼
            ┌────────────────┐
            │ Strategy Layer │
            │ - Signal Gen   │
            │ - Execution    │
            └────────┬───────┘
                     │
                     ▼
            ┌────────────────┐
            │  Risk Manager  │
            │ - VaR/CVaR     │
            │ - Kelly        │
            │ - Position Size│
            └────────┬───────┘
                     │
                     ▼
            ┌────────────────┐
            │ Order Execution│
            └────────────────┘
```

**Ключевой момент**: QuoteFrame → **все индикаторы** (технические и статистические) → остальные слои

### 9. Тестирование

```rust
// tests/indicators/statistical/garch_test.rs
#[cfg(test)]
mod garch_tests {
    use super::*;
    
    #[test]
    fn test_garch_basic() {
        let mut garch = GARCHIndicator::new(0.01, 0.1, 0.8);
        let data = load_test_data("spy_returns.parquet");
        
        let result = garch.calculate(&data).unwrap();
        
        // Проверяем базовые свойства
        assert!(result.len() == data.len());
        assert!(result.iter().all(|&v| v > 0.0)); // волатильность положительна
        
        // Проверяем стационарность GARCH
        assert!(0.1 + 0.8 < 1.0); // α + β < 1 для стационарности
    }
    
    #[test]
    fn test_garch_against_python() {
        // Сравниваем с arch package из Python
        let mut garch = GARCHIndicator::new(0.01, 0.1, 0.8);
        let data = load_test_data("known_dataset.parquet");
        
        let rust_result = garch.calculate(&data).unwrap();
        let python_result = load_expected("garch_python_output.csv");
        
        // Проверяем совпадение с точностью до 1e-6
        for (r, p) in rust_result.iter().zip(python_result.iter()) {
            assert!((r - p).abs() < 1e-6);
        }
    }
    
    #[test]
    fn test_indicator_interface() {
        // Проверяем, что GARCH правильно имплементирует Indicator trait
        let mut garch: Box<dyn Indicator> = Box::new(GARCHIndicator::new(0.01, 0.1, 0.8));
        
        let data = load_test_data("spy.parquet");
        let result = garch.calculate(&data);
        
        assert!(result.is_ok());
    }
}

// tests/indicators/statistical/arima_test.rs
#[cfg(test)]
mod arima_tests {
    #[test]
    fn test_arima_forecast() {
        let mut arima = ARIMAIndicator::new(2, 1, 2);
        let data = load_test_data("timeseries.parquet");
        
        let forecast = arima.calculate(&data).unwrap();
        
        // Проверяем корректность прогноза
        assert!(forecast.len() > 0);
    }
    
    #[test]
    fn test_arima_against_statsmodels() {
        // Сравниваем с statsmodels из Python
        let mut arima = ARIMAIndicator::new(2, 1, 2);
        let data = load_test_data("known_dataset.parquet");
        
        let rust_result = arima.calculate(&data).unwrap();
        let python_result = load_expected("arima_statsmodels_output.csv");
        
        compare_results(&rust_result, &python_result, 1e-4);
    }
}

// tests/integration/strategy_discovery_test.rs
#[cfg(test)]
mod integration_tests {
    #[test]
    fn test_statistical_strategy_end_to_end() {
        // Полный пайплайн: данные → индикаторы → стратегия → сигналы
        let mut registry = IndicatorRegistry::register_all();
        
        // Создаем стратегию с статистическими индикаторами
        let strategy = Strategy::builder()
            .add_indicator("GARCH", params![omega: 0.01, alpha: 0.1, beta: 0.8])
            .add_indicator("ARIMA", params![p: 2, d: 1, q: 2])
            .add_condition("vol_filter", "GARCH < 0.02")
            .add_condition("forecast_positive", "ARIMA > 0")
            .build();
        
        // Загружаем данные
        let data = load_historical_data("SPY", "2020-01-01", "2023-12-31");
        
        // Выполняем стратегию
        let signals = strategy.run(&data).unwrap();
        
        // Проверяем результаты
        assert!(signals.len() > 0);
        assert!(signals.iter().any(|s| s.is_long()));
    }
    
    #[test]
    fn test_strategy_discovery_with_statistical_indicators() {
        let discovery = StrategyDiscovery::new();
        
        // Генерируем стратегии, включая статистические
        let strategies = discovery.discover_strategies(1000);
        
        // Проверяем, что есть комбинации с статистическими индикаторами
        let has_garch = strategies.iter()
            .any(|s| s.uses_indicator("GARCH"));
        let has_arima = strategies.iter()
            .any(|s| s.uses_indicator("ARIMA"));
        
        assert!(has_garch);
        assert!(has_arima);
    }
}

// benches/statistical_indicators_bench.rs
#[bench]
fn bench_garch_calculation(b: &mut Bencher) {
    let mut garch = GARCHIndicator::new(0.01, 0.1, 0.8);
    let data = load_large_dataset(10000); // 10k bars
    
    b.iter(|| {
        garch.calculate(&data)
    });
}

#[bench]
fn bench_hmm_viterbi(b: &mut Bencher) {
    let mut hmm = HMMIndicator::new(3); // 3 states
    let data = load_large_dataset(10000);
    
    b.iter(|| {
        hmm.calculate(&data)
    });
}
```

**Типы тестов**:
1. **Unit tests** - каждый индикатор отдельно
2. **Integration tests** - полный пайплайн
3. **Validation tests** - сравнение с Python (arch, statsmodels, sklearn)
4. **Benchmark tests** - производительность
5. **Property-based tests** - QuickCheck для корректности

---

## Выводы и рекомендации

### Ключевая архитектурная идея: ВСЁ - ИНДИКАТОРЫ

**КРИТИЧЕСКИ ВАЖНО**: Статистические методы - это НЕ отдельная система "моделей", а **индикаторы** с более сложной математикой внутри.

#### Почему это правильно:

1. **Единый интерфейс**
   - SMA, GARCH, ARIMA - все имплементируют `Indicator` trait
   - Одна система регистрации, создания, выполнения
   - Нет дублирования кода и архитектуры

2. **Автоматическая комбинаторика**
   - Strategy Discovery сразу получает доступ ко всем методам
   - Можно комбинировать: `SMA + GARCH + HMM` без специального кода
   - Генетический алгоритм оптимизирует все параметры одинаково

3. **Переиспользование инфраструктуры**
   - Registry: регистрация всех индикаторов
   - Factory: создание по имени + параметры
   - Execution Engine: DAG для всех индикаторов
   - Caching: кэширование результатов для всех

4. **Простота расширения**
   - Добавить новый статистический метод = добавить новый индикатор
   - Не нужно интегрировать в отдельную систему
   - Сразу доступен в Strategy Discovery

### Преимущества для проекта

1. **Мощный автоматический поиск**
   ```
   Технические (50) × Статистические (100+) × Условия → 
   Миллионы возможных стратегий
   ```

2. **Адаптивность на всех уровнях**
   - Технические: адаптивные периоды
   - Статистические: HMM, SETAR (смена режимов)
   - Риск: динамический Kelly, adaptive VaR

3. **Научная обоснованность**
   - Технический анализ: паттерны и тренды
   - Эконометрика: статистические тесты и модели
   - ML: Gaussian Processes, Particle Filters
   - Всё в одной системе!

4. **Производительность**
   - Rust: zero-cost abstractions
   - SIMD: векторизация для всех индикаторов
   - GPU: для тяжелых вычислений (HMM, Particle Filter)
   - Parallel DAG: независимые индикаторы параллельно

### Синергия слоев

```
┌─────────────────────────────────────────────────────────┐
│           INDICATOR LAYER (Единая система)              │
│  ┌──────────────────┐  ┌────────────────────────────┐  │
│  │   Technical      │  │      Statistical           │  │
│  │   - SMA          │  │      - GARCH               │  │
│  │   - RSI          │  │      - ARIMA               │  │
│  │   - MACD         │  │      - HMM                 │  │
│  │   - Bollinger    │  │      - Kalman              │  │
│  │   (50+ методов)  │  │      (100+ методов)        │  │
│  └──────────────────┘  └────────────────────────────┘  │
└─────────────────────┬───────────────────────────────────┘
                      │ Все используют Indicator trait
                      ▼
┌─────────────────────────────────────────────────────────┐
│              CONDITION LAYER                            │
│  Использует индикаторы для создания условий             │
│  - RSI > 70, GARCH < 0.02, HMM == BullishRegime        │
└─────────────────────┬───────────────────────────────────┘
                      ▼
┌─────────────────────────────────────────────────────────┐
│              STRATEGY LAYER                             │
│  Комбинирует индикаторы + условия                       │
│  Strategy Discovery генерирует все комбинации           │
└─────────────────────┬───────────────────────────────────┘
                      ▼
┌─────────────────────────────────────────────────────────┐
│           OPTIMIZATION LAYER                            │
│  Оптимизирует параметры ВСЕХ индикаторов                │
│  Genetic Algorithm, Bayesian Optimization               │
└─────────────────────┬───────────────────────────────────┘
                      ▼
┌─────────────────────────────────────────────────────────┐
│              RISK MANAGEMENT                            │
│  VaR, CVaR, Kelly - тоже индикаторы!                    │
└─────────────────────────────────────────────────────────┘
```

### Уникальность vs конкуренты

| Возможность | OsEngine | MetaTrader | **Наш проект** |
|-------------|----------|------------|----------------|
| Технические индикаторы | ✅ 50+ | ✅ 100+ | ✅ 50+ |
| Статистические методы | ❌ Нет | ❌ Нет | ✅ **100+** |
| Автопоиск стратегий | ⚠️ Ограничен | ❌ Нет | ✅ **Миллионы комбинаций** |
| Единая система | ❌ Раздельно | ❌ Раздельно | ✅ **Unified Indicator Layer** |
| Производительность | ⚠️ C# | ⚠️ MQL | ✅ **Rust + SIMD + GPU** |
| Научность | ⚠️ Базовая | ⚠️ TA only | ✅ **TA + Econometrics + ML** |
| Open Source | ✅ | ❌ | ✅ |

### Практические примеры преимуществ

**Пример 1: Pairs Trading**
```rust
// Классический подход: отдельная система
pairs_trading_system.add_spread_calculation()
pairs_trading_system.add_cointegration_test()

// Наш подход: всё индикаторы!
strategy.add_indicator("OU_SPREAD", params![asset1: "GLD", asset2: "SLV"])
strategy.add_indicator("ZSCORE", params![window: 20])
strategy.add_condition("entry", "ZSCORE > 2.0")
```

**Пример 2: Regime-Adaptive Strategy**
```rust
// Определяем режим через HMM
strategy.add_indicator("regime", "HMM", params![n_states: 3])

// В бычьем режиме - агрессивные параметры
strategy.add_rule("IF regime == BULLISH THEN use SMA(10)")

// В медвежьем - консервативные
strategy.add_rule("IF regime == BEARISH THEN use SMA(50)")

// Всё через единую систему индикаторов!
```

**Пример 3: Volatility-Adjusted Position Sizing**
```rust
// Волатильность через GARCH
strategy.add_indicator("vol", "GARCH", params![...])

// Размер позиции через Kelly с учетом волатильности
strategy.add_indicator("size", "KELLY_VOLATILITY_ADJUSTED", params![
    vol_indicator: "vol",
    base_kelly: 0.1
])

// Риск-лимит через VaR
strategy.add_indicator("var", "VAR", params![confidence: 0.95])
strategy.add_condition("risk_ok", "size * price < var")
```

---

## План внедрения (Roadmap)

### Фаза 1: Базовые статистические индикаторы (2-3 недели)

**Must-Have индикаторы**:
1. ✅ `GARCHIndicator` - волатильность
2. ✅ `ARIMAIndicator` - прогнозирование
3. ✅ `OUProcessIndicator` - pairs trading
4. ✅ `HurstExponentIndicator` - выбор режима
5. ✅ `VaRIndicator` - риск
6. ✅ `CVaRIndicator` - tail risk
7. ✅ `KellyCriterionIndicator` - position sizing
8. ✅ `ADFTestIndicator` - stationarity test
9. ✅ `KalmanFilterIndicator` - adaptive filtering
10. ✅ `CointegrationSpreadIndicator` - spread calculation

**Задачи**:
- [ ] Создать `src/indicators/statistical/` структуру
- [ ] Имплементировать trait `Indicator` для каждого
- [ ] Зарегистрировать в `IndicatorRegistry`
- [ ] Написать unit tests с валидацией против Python
- [ ] Добавить benchmarks

### Фаза 2: Продвинутые индикаторы (3-4 недели)

**Should-Have индикаторы**:
1. `HMMIndicator` - regime detection
2. `DCCGARCHIndicator` - dynamic correlations
3. `SETARIndicator` / `STARIndicator` - nonlinear
4. `JohansenTestIndicator` - multi-asset cointegration
5. `VARIndicator` / `VECMIndicator` - multivariate forecasting
6. `PCAIndicator` - factor extraction
7. `FamaFrenchIndicator` - factor models
8. `HARIndicator` - realized volatility
9. `HawkesProcessIndicator` - microstructure
10. `WaveletIndicator` - multi-resolution

**Задачи**:
- [ ] Имплементировать сложные алгоритмы
- [ ] Оптимизировать производительность (SIMD)
- [ ] Интеграция с Strategy Discovery
- [ ] Создать примеры стратегий

### Фаза 3: Интеграция и оптимизация (2-3 недели)

**Задачи**:
- [ ] Strategy Discovery с статистическими индикаторами
- [ ] Genetic Algorithm оптимизация параметров
- [ ] Multi-objective optimization (Sharpe + Sortino + Calmar)
- [ ] Walk-forward validation
- [ ] Performance optimization (GPU для HMM)
- [ ] Documentation и примеры

### Фаза 4: Расширенные возможности (опционально)

**Nice-to-Have индикаторы**:
1. `GaussianProcessIndicator` - nonparametric forecasting
2. `ParticleFilterIndicator` - nonlinear estimation
3. `BayesianVARIndicator` - Bayesian forecasting
4. `DirichletProcessIndicator` - infinite mixture
5. `QuantileRegressionIndicator` - tail modeling

---

## Практические рекомендации для разработчиков

### 1. При добавлении нового статистического индикатора:

```rust
// Шаг 1: Создать структуру
pub struct MyStatisticalIndicator {
    // Параметры модели
    param1: f64,
    param2: usize,
    // Внутреннее состояние (если нужно)
    state: Option<InternalState>,
}

// Шаг 2: Имплементировать Indicator trait
impl Indicator for MyStatisticalIndicator {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        // Ваша статистическая логика
        let result = self.compute_statistics(data)?;
        Ok(IndicatorResult::Vector(result))
    }
    
    fn name(&self) -> &str {
        "MY_STAT"
    }
    
    fn parameters(&self) -> &Parameters {
        &self.params
    }
}

// Шаг 3: Зарегистрировать
registry.register("MY_STAT", Box::new(MyStatisticalIndicator::new));

// Шаг 4: Написать тесты
#[test]
fn test_my_stat_against_python() { ... }

// Готово! Автоматически доступен в Strategy Discovery
```

### 2. Валидация против Python библиотек:

```python
# Python (reference implementation)
import arch
from arch import arch_model

model = arch_model(returns, vol='GARCH', p=1, q=1)
result = model.fit()
print(result.conditional_volatility)
```

```rust
// Rust (наша реализация)
let mut garch = GARCHIndicator::new(omega, alpha, beta);
let vol = garch.calculate(&data)?;

// В тестах: сравниваем с Python результатами
assert_approx_eq!(vol, python_result, 1e-6);
```

### 3. Оптимизация производительности:

```rust
// Используйте ndarray для векторизации
use ndarray::{Array1, Array2};

impl GARCHIndicator {
    fn estimate_vectorized(&self, returns: &Array1<f64>) -> Array1<f64> {
        // SIMD автоматически через ndarray
        let squared_returns = returns.mapv(|r| r.powi(2));
        // ... остальная логика
    }
}

// Для тяжелых вычислений - параллелизм
use rayon::prelude::*;

strategies.par_iter_mut()
    .for_each(|s| {
        s.calculate_all_indicators(&data);
    });
```

### 4. Кэширование результатов:

```rust
pub struct CachedIndicator<I: Indicator> {
    inner: I,
    cache: HashMap<DataHash, IndicatorResult>,
}

impl<I: Indicator> Indicator for CachedIndicator<I> {
    fn calculate(&mut self, data: &QuoteFrame) -> Result<IndicatorResult> {
        let hash = data.hash();
        if let Some(cached) = self.cache.get(&hash) {
            return Ok(cached.clone());
        }
        let result = self.inner.calculate(data)?;
        self.cache.insert(hash, result.clone());
        Ok(result)
    }
}
```

---

## Заключение

Ключевая идея: **НЕ создаем отдельную систему "моделей"**, а **расширяем существующий Indicator Layer** статистическими методами.

### Преимущества подхода:
✅ Единая архитектура  
✅ Переиспользование инфраструктуры  
✅ Автоматическая комбинаторика в Strategy Discovery  
✅ Простота расширения  
✅ Мощь научных методов  
✅ Производительность Rust  

### Результат:
Система, которая превосходит конкурентов по:
- Количеству методов (150+ vs 50)
- Научной обоснованности (TA + Econometrics + ML)
- Производительности (Rust + SIMD + GPU)
- Гибкости (миллионы автогенерируемых стратегий)

**Следующий шаг**: Начать с Фазы 1 - базовые 10 статистических индикаторов.

---

**Модель AI**: Claude Sonnet 4.5

