# Анализ возможностей кэширования для генетической оптимизации

## Цель анализа
Определить все компоненты системы, которые можно кэшировать для ускорения генетической оптимизации при работе в 50+ потоках.

## Основные компоненты для кэширования

### 1. ✅ Индикаторы (ВЫСОКИЙ ПРИОРИТЕТ)

**Что кэшировать**: Результаты расчета индикаторов (SMA, EMA, RSI, ATR, MACD и т.д.)

**Ключ кэша**:
```rust
struct IndicatorCacheKey {
    timeframe: TimeFrame,
    indicator_name: String,        // "SMA", "EMA", "RSI" и т.д.
    parameters: Vec<(String, u32)>, // sorted: [("period", 20), ...]
    data_length: usize,            // длина входных данных
    data_hash: u64,                // хэш OHLC данных для проверки
}
```

**Потенциальная экономия**: 
- При оптимизации часто используются одинаковые индикаторы с одинаковыми параметрами
- Например, SMA(20) может использоваться в 100+ стратегиях
- Экономия: 50-90% времени на расчет индикаторов

**Пример использования**:
```rust
// Без кэша: каждый раз пересчитывается
let sma_20 = calculate_sma(data, 20); // 100ms

// С кэшем: берется из кэша
let sma_20 = cache.get_indicator("SMA", params, data_hash)?; // 0.1ms
```

---

### 2. ✅ Агрегированные таймфреймы (ВЫСОКИЙ ПРИОРИТЕТ)

**Что кэшировать**: Результаты агрегации таймфреймов (5min -> 15min, 60min -> 240min и т.д.)

**Ключ кэша**:
```rust
struct TimeframeAggregationCacheKey {
    base_timeframe: TimeFrame,     // исходный таймфрейм (5min)
    target_timeframe: TimeFrame,   // целевой таймфрейм (15min)
    base_data_hash: u64,           // хэш исходных данных
    base_data_length: usize,       // длина исходных данных
}
```

**Потенциальная экономия**:
- Агрегация таймфреймов - дорогая операция (создание новых свечей)
- Многие стратегии используют одинаковые комбинации таймфреймов
- Экономия: 30-70% времени на агрегацию

**Пример использования**:
```rust
// Без кэша: каждый раз агрегируется
let tf_15min = aggregate_timeframe(tf_5min, TimeFrame::Minutes(15)); // 200ms

// С кэшем: берется из кэша
let tf_15min = cache.get_aggregated_timeframe(tf_5min, TimeFrame::Minutes(15))?; // 0.1ms
```

**Где используется**: `BacktestExecutor::new()` - метод `TimeFrameAggregator::aggregate()`

---

### 3. ✅ OHLC данные (СРЕДНИЙ ПРИОРИТЕТ)

**Что кэшировать**: Преобразованные OHLC данные (QuoteFrame -> OHLCData)

**Ключ кэша**:
```rust
struct OHLCDataCacheKey {
    timeframe: TimeFrame,
    data_hash: u64,                // хэш исходного QuoteFrame
    data_length: usize,
}
```

**Потенциальная экономия**:
- Преобразование QuoteFrame -> OHLCData происходит для каждого индикатора
- Если несколько индикаторов используют один таймфрейм, преобразование повторяется
- Экономия: 10-30% времени на подготовку данных

**Пример использования**:
```rust
// Без кэша: каждый раз преобразуется
let ohlc = frame.to_indicator_ohlc(); // 5ms

// С кэшем: берется из кэша
let ohlc = cache.get_ohlc_data(&frame)?; // 0.1ms
```

**Где используется**: `BacktestExecutor::populate_indicators()` - метод `frame.to_indicator_ohlc()`

---

### 4. ⚠️ Результаты условий (НИЗКИЙ ПРИОРИТЕТ - опционально)

**Что кэшировать**: Результаты проверки условий (condition.check())

**Ключ кэша**:
```rust
struct ConditionResultCacheKey {
    condition_id: String,
    condition_type: String,        // "indicator_price", "indicator_indicator" и т.д.
    input_data_hash: u64,          // хэш входных данных условия
    input_data_length: usize,
}
```

**Потенциальная экономия**:
- Условия проверяются на каждом баре
- Если входные данные одинаковые, результат можно кэшировать
- Экономия: 5-15% времени на проверку условий

**Проблемы**:
- Условия часто зависят от текущего индекса (index offset)
- Кэш может быть неэффективным из-за большого количества уникальных комбинаций
- Сложность определения когда данные "одинаковые"

**Рекомендация**: Реализовать только если будет доказана эффективность после профилирования

**Где используется**: `BacktestExecutor::populate_conditions()` - метод `condition.condition.check()`

---

### 5. ⚠️ Результаты формул (НИЗКИЙ ПРИОРИТЕТ - опционально)

**Что кэшировать**: Результаты вычисления формул (FormulaDefinition::evaluate())

**Ключ кэша**:
```rust
struct FormulaCacheKey {
    timeframe: TimeFrame,
    expression: String,            // формула (например, "SMA(20) + SMA(50)")
    dependencies_hash: u64,        // хэш зависимостей (входных индикаторов)
    data_length: usize,
}
```

**Потенциальная экономия**:
- Формулы могут повторяться между стратегиями
- Экономия: 10-20% времени на вычисление формул

**Проблемы**:
- Формулы часто уникальны для каждой стратегии
- Зависимости могут быть сложными для хэширования

**Рекомендация**: Реализовать только если будет доказана эффективность

**Где используется**: `IndicatorRuntimeEngine::compute_formula()`

---

## Дополнительные возможности оптимизации

### 6. Кэш вычисления хэшей данных

**Что кэшировать**: Хэши OHLC данных для быстрого сравнения

**Идея**: Вычислять хэш один раз при загрузке данных, а не при каждом обращении к кэшу

**Потенциальная экономия**: 5-10% времени на проверку кэша

---

### 7. Кэш метаданных стратегий

**Что кэшировать**: Метаданные стратегий (indicator_bindings, conditions, rules)

**Идея**: Если стратегия с одинаковой структурой уже была обработана, можно переиспользовать метаданные

**Потенциальная экономия**: 2-5% времени на подготовку стратегии

**Проблемы**: Метаданные обычно уникальны для каждой стратегии

---

### 8. Кэш результатов backtest (уже реализован)

**Что кэшировать**: Полные результаты backtest для одинаковых стратегий и параметров

**Статус**: ✅ Уже реализовано в `StrategyEvaluationRunner` через `CacheKey`

**Где используется**: `evaluator.rs` - кэш `BacktestReport`

---

## Приоритизация реализации

### Фаза 1 (Критично - реализовать первым):
1. ✅ **Кэш индикаторов** - максимальная экономия времени
2. ✅ **Кэш агрегированных таймфреймов** - высокая экономия времени

### Фаза 2 (Важно - реализовать вторым):
3. ✅ **Кэш OHLC данных** - средняя экономия времени

### Фаза 3 (Опционально - после профилирования):
4. ⚠️ **Кэш результатов условий** - низкая экономия, сложная реализация
5. ⚠️ **Кэш результатов формул** - низкая экономия, сложная реализация

---

## Ожидаемый общий эффект

### Без кэширования:
- Время оптимизации: 100% (базовая линия)
- CPU usage: 100%
- Memory usage: базовая

### С кэшированием (Фаза 1 + Фаза 2):
- Время оптимизации: **30-50%** от исходного (ускорение в 2-3 раза)
- CPU usage: **40-60%** (меньше вычислений)
- Memory usage: +20-50% (кэш данных)

### С полным кэшированием (все фазы):
- Время оптимизации: **20-40%** от исходного (ускорение в 2.5-5 раз)
- CPU usage: **30-50%**
- Memory usage: +30-70%

---

## Технические детали реализации

### Структура глобального кэша

```rust
pub struct GlobalOptimizationCache {
    // Основные кэши
    indicators: DashMap<IndicatorCacheKey, Arc<Vec<f32>>>,
    aggregated_timeframes: DashMap<TimeframeAggregationCacheKey, Arc<QuoteFrame>>,
    ohlc_data: DashMap<OHLCDataCacheKey, Arc<OHLCData>>,
    
    // Опциональные кэши
    condition_results: Option<DashMap<ConditionResultCacheKey, Arc<ConditionResultData>>>,
    formula_results: Option<DashMap<FormulaCacheKey, Arc<Vec<f32>>>>,
    
    // Метрики
    stats: CacheStatistics,
}

pub struct CacheStatistics {
    indicator_hits: AtomicU64,
    indicator_misses: AtomicU64,
    timeframe_hits: AtomicU64,
    timeframe_misses: AtomicU64,
    ohlc_hits: AtomicU64,
    ohlc_misses: AtomicU64,
    total_memory_bytes: AtomicU64,
}
```

### Стратегия очистки кэша

1. **LRU (Least Recently Used)**: Удалять наименее используемые записи при достижении лимита памяти
2. **TTL (Time To Live)**: Удалять записи старше определенного времени
3. **Size-based**: Ограничить размер кэша по количеству записей
4. **Manual clear**: Очистка между запусками оптимизации

### Управление памятью

- Мониторинг размера кэша
- Автоматическая очистка при превышении лимита
- Статистика использования памяти
- Оптимизация размера ключей (минимизация дублирования)

---

## Метрики для мониторинга

1. **Hit Rate**: Процент попаданий в кэш (цель: >70%)
2. **Cache Size**: Размер кэша в записях и байтах
3. **Memory Usage**: Использование памяти кэшем
4. **Time Saved**: Время, сэкономленное благодаря кэшу
5. **Throughput**: Количество операций в секунду

---

## Следующие шаги

1. ✅ Добавить задачу в tasks.md
2. Реализовать Фазу 1 (индикаторы + таймфреймы)
3. Профилировать производительность
4. Реализовать Фазу 2 (OHLC данные)
5. Профилировать и оптимизировать
6. Оценить необходимость Фазы 3 (условия + формулы)
7. Добавить метрики и мониторинг
8. Оптимизировать стратегию очистки кэша




