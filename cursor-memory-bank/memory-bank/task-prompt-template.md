# Шаблон промпта для описания задачи разработки

## Инструкция по использованию
Заполните все разделы ниже для создания полного технического задания. Этот шаблон объединяет подходы бизнес-аналитика, системного аналитика, тимлида и техлида.

---

## 1. БИЗНЕС-КОНТЕКСТ И ЦЕЛИ

### 1.1. Бизнес-проблема
**Описание:** [Опишите проблему, которую решает эта задача, с точки зрения бизнеса]

**Пример:**
- Пользователи не могут быстро найти нужную торговую стратегию среди тысяч вариантов
- Текущий процесс оптимизации стратегий занимает слишком много времени
- Отсутствует автоматизация процесса генерации новых стратегий

### 1.2. Бизнес-цели
**Что мы хотим достичь:**
- [ ] Цель 1: [Конкретная измеримая цель]
- [ ] Цель 2: [Конкретная измеримая цель]
- [ ] Цель 3: [Конкретная измеримая цель]

**Метрики успеха (KPI):**
- Метрика 1: [Название] - [Текущее значение] → [Целевое значение] за [Срок]
- Метрика 2: [Название] - [Текущее значение] → [Целевое значение] за [Срок]

### 1.3. Целевая аудитория
**Кто будет использовать:**
- [ ] Внутренние пользователи (разработчики, аналитики)
- [ ] Внешние пользователи (трейдеры, клиенты)
- [ ] Системные интеграции (API, другие сервисы)

**Пользовательские сценарии:**
1. [Роль пользователя] хочет [действие], чтобы [результат]
2. [Роль пользователя] хочет [действие], чтобы [результат]

### 1.4. Приоритет и сроки
- **Приоритет:** [Критический / Высокий / Средний / Низкий]
- **Желаемый срок завершения:** [Дата]
- **Критический путь:** [Да, если блокирует другие задачи / Нет]
- **Бизнес-имп act:** [Описание последствий задержки]

---

## 2. ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ

### 2.1. Основная функциональность
**Что должна делать система:**

**Сценарий 1: [Название сценария]**
- **Действие:** [Что делает пользователь/система]
- **Входные данные:** [Что на входе]
- **Ожидаемое поведение:** [Как система должна реагировать]
- **Выходные данные:** [Что на выходе]
- **Исключения:** [Что делать при ошибках]

**Сценарий 2: [Название сценария]**
- [Аналогично выше]

### 2.2. Дополнительная функциональность
**Желательные, но не обязательные функции:**
- [ ] Функция 1: [Описание]
- [ ] Функция 2: [Описание]

### 2.3. Граничные случаи и исключения
**Что система НЕ должна делать:**
- [ ] Система не должна [действие]
- [ ] Система должна игнорировать [входные данные]

**Обработка ошибок:**
- При ошибке типа [X] система должна [действие]
- При ошибке типа [Y] система должна [действие]

---

## 3. СИСТЕМНЫЙ АНАЛИЗ И АРХИТЕКТУРА

### 3.1. Текущее состояние системы
**Что уже существует:**
- [ ] Компонент 1: [Описание, расположение в коде]
- [ ] Компонент 2: [Описание, расположение в коде]

**Связанные модули/системы:**
- Модуль A: [Как связан, какие интерфейсы использует]
- Модуль B: [Как связан, какие интерфейсы использует]

### 3.2. Архитектурные требования
**Где должна быть реализована функциональность:**
- **Слой:** [Infrastructure / Data Model / Indicator / Condition / Position & Order / Risk Management / Metrics / Strategy Discovery / etc.]
- **Модуль:** [Название модуля или путь к файлу]
- **Интеграция с существующими компонентами:** [Как интегрируется]

**Архитектурные паттерны:**
- [ ] Использовать существующий паттерн: [Название паттерна]
- [ ] Создать новый паттерн: [Описание паттерна]

### 3.3. Зависимости и интеграции
**Внутренние зависимости:**
- Зависит от: [Модуль/компонент] - [Как используется]
- Используется в: [Модуль/компонент] - [Как будет использоваться]

**Внешние зависимости:**
- Библиотека/фреймворк: [Название, версия] - [Для чего]
- Внешний сервис/API: [Название] - [Для чего]

**Обратная совместимость:**
- [ ] Должна быть обратно совместима с [версия/компонент]
- [ ] Может нарушить совместимость с [версия/компонент] - [План миграции]

---

## 4. ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ

### 4.1. Технологический стек
**Язык программирования:** [Rust / Python / etc.]
**Версия:** [1.75.0 / etc.]
**Ключевые библиотеки:**
- [Библиотека 1]: [Версия] - [Назначение]
- [Библиотека 2]: [Версия] - [Назначение]

### 4.2. Структура данных
**Новые типы данных:**
```rust
// Пример структуры
pub struct NewType {
    field1: Type1,
    field2: Type2,
}
```

**Модификация существующих типов:**
- Тип: [Название] - [Что добавить/изменить]

### 4.3. Интерфейсы и API
**Публичные интерфейсы (traits/functions):**
```rust
// Пример интерфейса
pub trait NewTrait {
    fn method1(&self) -> Result<Type, Error>;
}
```

**Приватные интерфейсы:**
- [Описание внутренних интерфейсов]

**Изменения в существующих интерфейсах:**
- Интерфейс: [Название] - [Что изменить, почему]

### 4.4. Производительность
**Требования к производительности:**
- Время выполнения: [Максимальное время] для [операция]
- Память: [Максимальное использование памяти]
- Пропускная способность: [Количество операций в секунду]

**Оптимизации:**
- [ ] Использовать кэширование для [что кэшировать]
- [ ] Параллелизация для [что параллелизовать]
- [ ] Ленивая загрузка для [что загружать лениво]

### 4.5. Безопасность и надежность
**Обработка ошибок:**
- Типы ошибок: [Какие ошибки возможны]
- Стратегия обработки: [Как обрабатывать]

**Валидация данных:**
- Входные данные: [Что валидировать, как]
- Выходные данные: [Что валидировать, как]

**Устойчивость к сбоям:**
- [ ] Обработка паник
- [ ] Graceful degradation при [условие]
- [ ] Retry логика для [операция]

---

## 5. ПЛАН РАЗРАБОТКИ И УПРАВЛЕНИЕ

### 5.1. Разбивка на подзадачи
**Этап 1: [Название этапа]**
- [ ] Подзадача 1.1: [Описание] - [Оценка времени]
- [ ] Подзадача 1.2: [Описание] - [Оценка времени]

**Этап 2: [Название этапа]**
- [ ] Подзадача 2.1: [Описание] - [Оценка времени]
- [ ] Подзадача 2.2: [Описание] - [Оценка времени]

**Этап 3: [Название этапа]**
- [ ] Подзадача 3.1: [Описание] - [Оценка времени]

### 5.2. Последовательность выполнения
**Порядок разработки:**
1. Сначала: [Что делать первым и почему]
2. Затем: [Что делать вторым и почему]
3. В конце: [Что делать последним и почему]

**Параллельная разработка:**
- Можно разрабатывать параллельно: [Задачи, которые не зависят друг от друга]

### 5.3. Риски и митигация
**Технические риски:**
- Риск 1: [Описание] - Вероятность: [Высокая/Средняя/Низкая]
  - Митигация: [Как снизить риск]
  - План Б: [Что делать, если риск реализуется]

- Риск 2: [Описание] - Вероятность: [Высокая/Средняя/Низкая]
  - Митигация: [Как снизить риск]
  - План Б: [Что делать, если риск реализуется]

**Риски по срокам:**
- Риск: [Описание] - [Как митигировать]

### 5.4. Зависимости от других задач
**Блокирует:**
- [ ] Задача X не может начаться, пока не завершена эта задача

**Блокируется:**
- [ ] Эта задача не может начаться, пока не завершена задача Y

**Связанные задачи:**
- Задача Z: [Как связана, можно ли делать параллельно]

---

## 6. КРИТЕРИИ ПРИЕМКИ (ACCEPTANCE CRITERIA)

### 6.1. Функциональные критерии
**Критерий 1: [Название]**
- **Дано:** [Начальное состояние]
- **Когда:** [Действие]
- **Тогда:** [Ожидаемый результат]
- **И:** [Дополнительные проверки]

**Критерий 2: [Название]**
- [Аналогично выше]

### 6.2. Технические критерии
- [ ] Код проходит все существующие тесты
- [ ] Добавлены unit-тесты с покрытием не менее [X]%
- [ ] Добавлены integration-тесты для [что тестировать]
- [ ] Код соответствует стандартам проекта (rustfmt, clippy)
- [ ] Документация обновлена (doc comments, README)
- [ ] Нет утечек памяти (проверено через valgrind/miri)
- [ ] Производительность соответствует требованиям (бенчмарки)

### 6.3. Критерии качества
- [ ] Код ревью пройдено
- [ ] Нет критических багов
- [ ] Обратная совместимость сохранена (если требуется)
- [ ] Миграция данных выполнена (если требуется)

---

## 7. ТЕСТИРОВАНИЕ

### 7.1. Unit-тесты
**Что тестировать:**
- [ ] Функция/метод 1: [Какие случаи покрыть]
- [ ] Функция/метод 2: [Какие случаи покрыть]

**Примеры тестовых случаев:**
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_case_1() {
        // Arrange
        // Act
        // Assert
    }
}
```

### 7.2. Integration-тесты
**Что тестировать:**
- [ ] Интеграция с модулем A: [Сценарий]
- [ ] Интеграция с модулем B: [Сценарий]

### 7.3. Тесты производительности
**Бенчмарки:**
- [ ] Бенчмарк для [операция] - целевое время: [время]

### 7.4. Ручное тестирование
**Чек-лист для ручного тестирования:**
- [ ] Сценарий 1: [Шаги для проверки]
- [ ] Сценарий 2: [Шаги для проверки]

---

## 8. ДОКУМЕНТАЦИЯ

### 8.1. Документация кода
**Что документировать:**
- [ ] Публичные функции/методы: [doc comments]
- [ ] Публичные типы: [doc comments]
- [ ] Сложная логика: [inline comments где необходимо]

### 8.2. Обновление документации проекта
- [ ] Обновить [файл документации] - [Что добавить/изменить]
- [ ] Обновить архитектурную диаграмму (если требуется)
- [ ] Обновить README (если требуется)

### 8.3. Примеры использования
**Пример кода:**
```rust
// Пример использования новой функциональности
fn example() {
    // код примера
}
```

---

## 9. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ

### 9.1. Референсы и примеры
**Похожие реализации:**
- [Ссылка/описание] - [Что взять за основу]

**Документация:**
- [Ссылка на документацию библиотеки/технологии]

### 9.2. Ограничения и компромиссы
**Известные ограничения:**
- Ограничение 1: [Описание] - [Почему, можно ли обойти]
- Ограничение 2: [Описание] - [Почему, можно ли обойти]

**Принятые компромиссы:**
- Компромисс 1: [Что выбрали] вместо [альтернатива] - [Почему]

### 9.3. Вопросы для уточнения
**Требуется уточнение:**
- [ ] Вопрос 1: [Что нужно уточнить]
- [ ] Вопрос 2: [Что нужно уточнить]

---

## 10. ИСТОРИЯ ИЗМЕНЕНИЙ

### Версия 1.0 - [Дата]
- Первоначальная версия задачи
- Автор: [Имя]

### Версия 1.1 - [Дата]
- Изменение: [Что изменилось]
- Причина: [Почему изменилось]

---

## ИНСТРУКЦИЯ ДЛЯ AI-АССИСТЕНТА

При получении этой задачи, AI-ассистент должен:

1. **Проанализировать контекст:**
   - Изучить существующий код проекта
   - Понять архитектуру и паттерны
   - Определить точки интеграции

2. **Спланировать реализацию:**
   - Разбить задачу на конкретные шаги
   - Определить порядок реализации
   - Выявить потенциальные проблемы

3. **Реализовать:**
   - Следовать архитектурным паттернам проекта
   - Писать чистый, документированный код
   - Добавлять тесты параллельно с разработкой

4. **Проверить:**
   - Убедиться, что все критерии приемки выполнены
   - Проверить соответствие стандартам проекта
   - Убедиться в отсутствии регрессий

5. **Документировать:**
   - Обновить документацию кода
   - Обновить документацию проекта при необходимости
   - Предоставить примеры использования

---

## ПРИМЕЧАНИЯ

- Все разделы должны быть заполнены максимально подробно
- Если раздел не применим, укажите "N/A" с объяснением
- Используйте конкретные примеры вместо абстрактных описаний
- Указывайте конкретные пути к файлам, названия модулей, версии библиотек
- При необходимости добавляйте диаграммы, схемы, примеры кода

