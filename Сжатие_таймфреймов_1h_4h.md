# Сжатие таймфреймов: детальное описание на примере 1h → 4h

## Обзор

Документ описывает механизм агрегации (сжатия) таймфреймов - процесс преобразования котировок младшего таймфрейма в старший таймфрейм на примере объединения 1-часовых (1h) баров в 4-часовые (4h) бары.

## Архитектура компонентов

### Основные структуры данных

1. **Quote** - одна котировка (свеча) с полями OHLCV
2. **QuoteFrame** - коллекция котировок для конкретного таймфрейма
3. **AggregatedQuoteFrame** - результат агрегации с метаданными
4. **TimeFrameMetadata** - метаинформация об агрегации
5. **TimeFrameAggregator** - основной класс для агрегации

## Валидация возможности агрегации

### Метод `is_valid_aggregation`

**Расположение:** `src/candles/aggregator.rs:145-153`

```145:153:src/candles/aggregator.rs
    fn is_valid_aggregation(source: &TimeFrame, target: &TimeFrame) -> bool {
        let source_minutes = Self::timeframe_to_minutes(source);
        let target_minutes = Self::timeframe_to_minutes(target);

        match (source_minutes, target_minutes) {
            (Some(s), Some(t)) => t > s && t % s == 0,
            _ => false,
        }
    }
```

**Что проверяется:**

1. **Преобразование в минуты:** Оба таймфрейма должны успешно преобразоваться в минуты
2. **Старшинство:** Целевой таймфрейм должен быть старше исходного (`t > s`)
3. **Кратность:** Целевой таймфрейм должен быть кратен исходному (`t % s == 0`)

**Пример для 1h → 4h:**
- Исходный (1h): 60 минут
- Целевой (4h): 240 минут
- Проверка: `240 > 60` ✓ и `240 % 60 == 0` ✓
- Результат: валидация пройдена

**Недопустимые примеры:**
- 1h → 3h: `180 % 60 == 0` ✓, но обычно не используется
- 1h → 2h: `120 % 60 == 0` ✓ (допустимо)
- 1h → 30m: `60 > 30` ✗ (младший таймфрейм)
- 1h → 70m: `70 % 60 != 0` ✗ (не кратен)

## Расчет коэффициента агрегации

### Метод `calculate_ratio`

**Расположение:** `src/candles/aggregator.rs:155-171`

```155:171:src/candles/aggregator.rs
    fn calculate_ratio(
        source: &TimeFrame,
        target: &TimeFrame,
    ) -> Result<f64, TimeFrameAggregationError> {
        let source_minutes = Self::timeframe_to_minutes(source).ok_or_else(|| {
            TimeFrameAggregationError::UnsupportedTimeFrame(format!("{:?}", source))
        })?;
        let target_minutes = Self::timeframe_to_minutes(target).ok_or_else(|| {
            TimeFrameAggregationError::UnsupportedTimeFrame(format!("{:?}", target))
        })?;

        if target_minutes == 0 {
            return Err(TimeFrameAggregationError::InvalidTimeFrame);
        }

        Ok(target_minutes as f64 / source_minutes as f64)
    }
```

**Формула:**
```
ratio = target_minutes / source_minutes
```

**Пример для 1h → 4h:**
- `ratio = 240 / 60 = 4.0`
- Это означает, что один 4h бар состоит из 4 баров 1h

**Использование коэффициента:**
- Оценка количества результирующих баров: `estimated_bars = source_len / ratio`
- Валидация количества исходных баров в одном целевом баре

## Выравнивание временных меток

### Метод `align_to_timeframe`

**Расположение:** `src/candles/aggregator.rs:173-187`

```173:187:src/candles/aggregator.rs
    fn align_to_timeframe(
        timestamp: DateTime<Utc>,
        timeframe: &TimeFrame,
    ) -> Result<DateTime<Utc>, TimeFrameAggregationError> {
        let minutes = Self::timeframe_to_minutes(timeframe).ok_or_else(|| {
            TimeFrameAggregationError::UnsupportedTimeFrame(format!("{:?}", timeframe))
        })?;

        let total_minutes = timestamp.timestamp() / 60;
        let aligned_minutes = (total_minutes / minutes as i64) * minutes as i64;
        let aligned_timestamp = DateTime::from_timestamp(aligned_minutes * 60, 0)
            .ok_or(TimeFrameAggregationError::InvalidTimestamp)?;

        Ok(aligned_timestamp)
    }
```

**Процесс выравнивания:**

1. Преобразование таймфрейма в минуты: для 4h = 240 минут
2. Вычисление общего количества минут от эпохи Unix
3. Выравнивание до нижней границы через целочисленное деление: `(total_minutes / 240) * 240`
4. Преобразование обратно в DateTime

**Примеры:**

- `2025-11-07 11:37:00` → `2025-11-07 08:00:00` (граница 4h бара)
- `2025-11-07 08:00:00` → `2025-11-07 08:00:00` (уже на границе)
- `2025-11-07 12:30:00` → `2025-11-07 12:00:00` (граница следующего 4h периода)

## Основной метод агрегации `aggregate`

### Общий алгоритм

**Расположение:** `src/candles/aggregator.rs:25-124`

Метод `aggregate` является основным механизмом преобразования котировок из одного таймфрейма в другой.

### Шаг 1: Инициализация

```28:50:src/candles/aggregator.rs
    pub fn aggregate(
        source_frame: &QuoteFrame,
        target_timeframe: TimeFrame,
    ) -> Result<AggregatedQuoteFrame, TimeFrameAggregationError> {
        let source_tf = source_frame.timeframe();
        let symbol = source_frame.symbol().clone();

        if !Self::is_valid_aggregation(source_tf, &target_timeframe) {
            return Err(TimeFrameAggregationError::InvalidAggregation(
                format!("{:?}", source_tf),
                format!("{:?}", target_timeframe),
            ));
        }

        let ratio = Self::calculate_ratio(source_tf, &target_timeframe)?;
        let estimated_bars = (source_frame.len() as f64 / ratio as f64).ceil() as usize;
        let mut aggregated_quotes = Vec::with_capacity(estimated_bars);
        let mut source_indices = HashMap::with_capacity(estimated_bars);

        let mut current_bar_start: Option<DateTime<Utc>> = None;
        let mut current_bar_open: Option<Price> = None;
        let mut current_bar_high: Option<Price> = None;
        let mut current_bar_low: Option<Price> = None;
        let mut current_bar_close: Option<Price> = None;
        let mut current_bar_volume: Volume = 0.0;
        let mut current_bar_indices = Vec::with_capacity(ratio as usize);
```

**Что происходит:**

1. Проверка валидности агрегации
2. Расчет коэффициента агрегации (ratio = 4.0 для 1h → 4h)
3. Оценка количества результирующих баров
4. Инициализация переменных для текущего агрегируемого бара

### Шаг 2: Обработка исходных котировок

```52:88:src/candles/aggregator.rs
        for (idx, quote) in source_frame.iter().enumerate() {
            let quote_time = quote.timestamp();
            let bar_start = Self::align_to_timeframe(quote_time, &target_timeframe)?;

            if current_bar_start.is_none() || current_bar_start.unwrap() != bar_start {
                if current_bar_start.is_some() {
                    let aggregated_quote = Quote::from_parts(
                        symbol.clone(),
                        target_timeframe.clone(),
                        current_bar_start.unwrap(),
                        current_bar_open.unwrap(),
                        current_bar_high.unwrap(),
                        current_bar_low.unwrap(),
                        current_bar_close.unwrap(),
                        current_bar_volume,
                    );

                    let aggregated_idx = aggregated_quotes.len();
                    aggregated_quotes.push(aggregated_quote);
                    source_indices.insert(aggregated_idx, current_bar_indices.clone());
                }

                current_bar_start = Some(bar_start);
                current_bar_open = Some(quote.open());
                current_bar_high = Some(quote.high());
                current_bar_low = Some(quote.low());
                current_bar_close = Some(quote.close());
                current_bar_volume = quote.volume();
                current_bar_indices = vec![idx];
            } else {
                current_bar_high = Some(current_bar_high.unwrap().max(quote.high()));
                current_bar_low = Some(current_bar_low.unwrap().min(quote.low()));
                current_bar_close = Some(quote.close());
                current_bar_volume += quote.volume();
                current_bar_indices.push(idx);
            }
        }
```

**Логика обработки:**

#### Случай 1: Начало нового агрегированного бара

**Условие:** `current_bar_start.is_none() || current_bar_start != bar_start`

Это происходит, когда:
- Первая котировка в исходных данных
- Временная метка котировки выровнена к другой границе таймфрейма (начался новый 4h период)

**Действия:**

1. **Завершение предыдущего бара** (если был):
   - Создается агрегированная котировка из накопленных данных
   - Сохраняется маппинг исходных индексов

2. **Инициализация нового бара:**
   - `current_bar_start = bar_start` (выровненная временная метка)
   - `current_bar_open = quote.open()` (Open от первой котировки в периоде)
   - `current_bar_high = quote.high()` (первое значение High)
   - `current_bar_low = quote.low()` (первое значение Low)
   - `current_bar_close = quote.close()` (Close от последней обработанной котировки)
   - `current_bar_volume = quote.volume()` (Volume первой котировки)
   - `current_bar_indices = [idx]` (сохранение индекса исходной котировки)

#### Случай 2: Продолжение текущего агрегированного бара

**Условие:** `current_bar_start == bar_start`

Котировка принадлежит тому же 4h периоду.

**Действия:**

1. **Обновление High:** `max(current_bar_high, quote.high())`
   - Выбирается максимальное значение High среди всех котировок периода

2. **Обновление Low:** `min(current_bar_low, quote.low())`
   - Выбирается минимальное значение Low среди всех котировок периода

3. **Обновление Close:** `quote.close()`
   - Close всегда берется от последней котировки в периоде

4. **Суммирование Volume:** `current_bar_volume += quote.volume()`
   - Объемы всех котировок периода суммируются

5. **Сохранение индекса:** `current_bar_indices.push(idx)`
   - Добавление индекса исходной котировки для возможности обратной трассировки

### Шаг 3: Финализация последнего бара

```90:105:src/candles/aggregator.rs
        if current_bar_start.is_some() {
            let aggregated_quote = Quote::from_parts(
                symbol.clone(),
                target_timeframe.clone(),
                current_bar_start.unwrap(),
                current_bar_open.unwrap(),
                current_bar_high.unwrap(),
                current_bar_low.unwrap(),
                current_bar_close.unwrap(),
                current_bar_volume,
            );

            let aggregated_idx = aggregated_quotes.len();
            aggregated_quotes.push(aggregated_quote);
            source_indices.insert(aggregated_idx, current_bar_indices);
        }
```

После обработки всех исходных котировок финализируется последний незавершенный агрегированный бар (если был начат).

### Шаг 4: Создание результирующего фрейма

```107:123:src/candles/aggregator.rs
        let mut target_frame = QuoteFrame::new(symbol, target_timeframe.clone());
        for quote in aggregated_quotes {
            target_frame.push(quote)?;
        }

        let metadata = TimeFrameMetadata {
            source_timeframe: source_tf.clone(),
            target_timeframe: target_timeframe.clone(),
            aggregation_ratio: ratio,
            created_at: Utc::now(),
        };

        Ok(AggregatedQuoteFrame {
            frame: target_frame,
            metadata,
            source_indices,
        })
```

Создается результирующий `QuoteFrame` с агрегированными котировками и метаданными, включая маппинг исходных индексов.

## Правила вычисления OHLCV при агрегации

### Правила для 1h → 4h агрегации:

1. **Open (цена открытия):**
   - Берется от первой 1h котировки в 4h периоде
   - Пример: для периода 08:00-12:00 берется Open от котировки 08:00

2. **High (максимальная цена):**
   - Максимум всех High значений 1h котировок в периоде
   - `High = max(high_08:00, high_09:00, high_10:00, high_11:00)`

3. **Low (минимальная цена):**
   - Минимум всех Low значений 1h котировок в периоде
   - `Low = min(low_08:00, low_09:00, low_10:00, low_11:00)`

4. **Close (цена закрытия):**
   - Берется от последней 1h котировки в 4h периоде
   - Пример: для периода 08:00-12:00 берется Close от котировки 11:00

5. **Volume (объем):**
   - Сумма всех Volume значений 1h котировок в периоде
   - `Volume = volume_08:00 + volume_09:00 + volume_10:00 + volume_11:00`

6. **Timestamp (временная метка):**
   - Выровненная временная метка начала 4h периода
   - Пример: для периода 08:00-12:00 метка = `08:00:00`

## Пример агрегации на реальных данных

### Исходные данные 1h таймфрейма:

| Timestamp | Open | High | Low | Close | Volume |
|-----------|------|------|-----|-------|--------|
| 2025-11-07 08:00 | 50.50 | 50.80 | 50.45 | 50.65 | 1000 |
| 2025-11-07 09:00 | 50.65 | 50.90 | 50.60 | 50.75 | 1200 |
| 2025-11-07 10:00 | 50.75 | 51.00 | 50.70 | 50.85 | 1100 |
| 2025-11-07 11:00 | 50.85 | 51.20 | 50.80 | 51.00 | 1300 |
| 2025-11-07 12:00 | 51.00 | 51.30 | 50.95 | 51.15 | 1150 |
| 2025-11-07 13:00 | 51.15 | 51.40 | 51.10 | 51.25 | 1050 |
| 2025-11-07 14:00 | 51.25 | 51.50 | 51.20 | 51.35 | 1250 |
| 2025-11-07 15:00 | 51.35 | 51.60 | 51.30 | 51.45 | 1100 |

### Процесс агрегации в 4h:

#### Бар 1: Период 08:00-12:00

**Обработка котировок 08:00, 09:00, 10:00, 11:00:**

1. **08:00** - начало нового периода:
   - `bar_start = align_to_timeframe(08:00, 4h) = 08:00`
   - `current_bar_open = 50.50`
   - `current_bar_high = 50.80`
   - `current_bar_low = 50.45`
   - `current_bar_close = 50.65`
   - `current_bar_volume = 1000`

2. **09:00** - продолжение периода:
   - `current_bar_high = max(50.80, 50.90) = 50.90`
   - `current_bar_low = min(50.45, 50.60) = 50.45`
   - `current_bar_close = 50.75`
   - `current_bar_volume = 1000 + 1200 = 2200`

3. **10:00** - продолжение периода:
   - `current_bar_high = max(50.90, 51.00) = 51.00`
   - `current_bar_low = min(50.45, 50.70) = 50.45`
   - `current_bar_close = 50.85`
   - `current_bar_volume = 2200 + 1100 = 3300`

4. **11:00** - последняя котировка периода:
   - `current_bar_high = max(51.00, 51.20) = 51.20`
   - `current_bar_low = min(50.45, 50.80) = 50.45`
   - `current_bar_close = 51.00`
   - `current_bar_volume = 3300 + 1300 = 4600`

**Результирующий 4h бар:**
- Timestamp: `2025-11-07 08:00`
- Open: `50.50` (от 08:00)
- High: `51.20` (максимум за период)
- Low: `50.45` (минимум за период)
- Close: `51.00` (от 11:00 - последняя в периоде)
- Volume: `4600` (сумма всех объемов)

#### Бар 2: Период 12:00-16:00

**Обработка котировок 12:00, 13:00, 14:00, 15:00:**

1. **12:00** - начало нового периода:
   - `bar_start = align_to_timeframe(12:00, 4h) = 12:00`
   - Новый бар создается после завершения предыдущего

2. Аналогичная обработка для 13:00, 14:00, 15:00

**Результирующий 4h бар:**
- Timestamp: `2025-11-07 12:00`
- Open: `51.00` (от 12:00)
- High: `max(51.30, 51.40, 51.50, 51.60) = 51.60`
- Low: `min(50.95, 51.10, 51.20, 51.30) = 50.95`
- Close: `51.45` (от 15:00)
- Volume: `1150 + 1050 + 1250 + 1100 = 4550`

### Результирующие данные 4h таймфрейма:

| Timestamp | Open | High | Low | Close | Volume |
|-----------|------|------|-----|-------|--------|
| 2025-11-07 08:00 | 50.50 | 51.20 | 50.45 | 51.00 | 4600 |
| 2025-11-07 12:00 | 51.00 | 51.60 | 50.95 | 51.45 | 4550 |

## Альтернативный метод: `build_compressed_frame_from_source`

### Назначение

Метод `build_compressed_frame_from_source` выполняет агрегацию до указанного индекса, что полезно для пошаговой обработки данных.

**Расположение:** `src/candles/aggregator.rs:411-517`

### Основные отличия от `aggregate`:

1. **Ограничение по индексу:** Агрегирует только до указанного индекса `up_to_index`
2. **Строгая проверка времени:** Дополнительная проверка границ периода через `end_candle_time`
3. **Проверка завершенности:** Создает бар только если собрано достаточно котировок

### Алгоритм работы

```439:506:src/candles/aggregator.rs
        let mut i = 0;
        while i <= up_to_index.min(source_frame.len().saturating_sub(1)) {
            if let Some(first_quote) = source_frame.get(i) {
                let mut new_candle_start = first_quote.timestamp();
                let aligned_start = Self::align_to_timeframe(new_candle_start, target_timeframe)?;
                new_candle_start = aligned_start;

                let mut new_candle_open = first_quote.open();
                let mut new_candle_high = first_quote.high();
                let mut new_candle_low = first_quote.low();
                let mut new_candle_close = first_quote.close();
                let mut new_candle_volume = first_quote.volume();

                i += 1;

                let end_candle_time = new_candle_start + candle_minute_len;
                let mut collected_count = 1;

                for i2 in 0..(count_old_candles_in_one_new - 1) {
                    if i > up_to_index.min(source_frame.len().saturating_sub(1)) {
                        break;
                    }

                    if let Some(current_quote) = source_frame.get(i) {
                        let current_time = current_quote.timestamp();

                        if current_time >= end_candle_time {
                            i -= 1;
                            break;
                        }

                        if new_candle_start.date_naive() != current_time.date_naive() {
                            i -= 1;
                            break;
                        }

                        if current_quote.high() > new_candle_high {
                            new_candle_high = current_quote.high();
                        }
                        if current_quote.low() < new_candle_low {
                            new_candle_low = current_quote.low();
                        }

                        new_candle_close = current_quote.close();
                        new_candle_volume += current_quote.volume();
                        collected_count += 1;

                        if i2 + 1 < count_old_candles_in_one_new - 1 {
                            i += 1;
                        }
                    } else {
                        break;
                    }
                }

                if collected_count >= count_old_candles_in_one_new {
                    let aggregated_quote = Quote::from_parts(
                        source_frame.symbol().clone(),
                        target_timeframe.clone(),
                        new_candle_start,
                        new_candle_open,
                        new_candle_high,
                        new_candle_low,
                        new_candle_close,
                        new_candle_volume,
                    );
                    result_frame.push(aggregated_quote)?;
                }

                i += 1;
            } else {
                i += 1;
            }
        }
```

**Ключевые особенности:**

1. **Выравнивание начала:** Первая котировка выравнивается до границы целевого таймфрейма
2. **Проверка границ:** Проверяется, что котировка не выходит за `end_candle_time`
3. **Проверка даты:** Котировки должны быть в один день
4. **Проверка завершенности:** Бар создается только если собрано `count_old_candles_in_one_new` котировок (4 для 1h → 4h)

## Маппинг исходных индексов

### Структура `source_indices`

Агрегированный фрейм сохраняет маппинг между индексами агрегированных и исходных котировок:

```71:71:src/candles/aggregator.rs
                    source_indices.insert(aggregated_idx, current_bar_indices.clone());
```

**Пример:**
- Агрегированный бар с индексом 0 (период 08:00-12:00) соответствует исходным индексам `[0, 1, 2, 3]`
- Агрегированный бар с индексом 1 (период 12:00-16:00) соответствует исходным индексам `[4, 5, 6, 7]`

**Использование:**

```377:392:src/candles/aggregator.rs
    pub fn get_source_indices(&self, aggregated_index: usize) -> Option<&Vec<usize>> {
        self.source_indices.get(&aggregated_index)
    }

    pub fn get_source_quotes<'a>(
        &self,
        aggregated_index: usize,
        source_frame: &'a QuoteFrame,
    ) -> Option<Vec<&'a Quote>> {
        self.get_source_indices(aggregated_index).map(|indices| {
            indices
                .iter()
                .filter_map(|idx| source_frame.get(*idx))
                .collect()
        })
    }
```

Это позволяет:
- Отследить, какие исходные котировки вошли в агрегированный бар
- Восстановить исходные данные (через метод `expand`)
- Провести обратную трассировку при анализе

## Границы таймфреймов и их влияние на агрегацию

### 4h таймфрейм (240 минут)

4-часовые бары начинаются в моменты:
- `00:00:00` (начало дня)
- `04:00:00`
- `08:00:00`
- `12:00:00`
- `16:00:00`
- `20:00:00`

**Важно:** Все 1h котировки в промежутке `[08:00, 12:00)` принадлежат одному 4h бару с началом в `08:00:00`.

### 1h таймфрейм (60 минут)

1-часовые бары начинаются в моменты:
- `00:00:00`
- `01:00:00`
- `02:00:00`
- ...
- `23:00:00`

## Обработка граничных случаев

### 1. Неполный последний бар

Если количество исходных котировок не кратно коэффициенту агрегации, последний бар создается с неполным набором данных:

**Пример:** 10 котировок 1h при агрегации в 4h (коэффициент = 4):
- Бар 1: котировки 0-3 (полный)
- Бар 2: котировки 4-7 (полный)
- Бар 3: котировки 8-9 (неполный, только 2 из 4)

Метод `aggregate` создает неполный бар, используя доступные данные.

### 2. Пропуски в данных

Если в исходных данных есть пропуски (например, отсутствует котировка 10:00), агрегация продолжается:

- Котировки 08:00, 09:00, 11:00, 12:00 будут объединены
- Отсутствие 10:00 не влияет на логику агрегации
- High и Low вычисляются только из доступных данных

### 3. Переход через границу дня

Метод `build_compressed_frame_from_source` проверяет дату:

```470:473:src/candles/aggregator.rs
                        if new_candle_start.date_naive() != current_time.date_naive() {
                            i -= 1;
                            break;
                        }
```

Если котировка относится к другому дню, текущий агрегированный бар завершается.

## Производительность

### Оптимизации:

1. **Предварительное выделение памяти:** `Vec::with_capacity(estimated_bars)`
2. **Единый проход:** Обработка исходных данных за один цикл
3. **Хеш-маппинг:** Быстрый доступ к маппингу индексов через HashMap

### Сложность:

- **Временная:** O(n), где n - количество исходных котировок
- **Пространственная:** O(m), где m - количество агрегированных котировок

## Заключение

Механизм сжатия таймфреймов обеспечивает:

1. **Корректную агрегацию** OHLCV данных с сохранением финансовой логики
2. **Выравнивание по границам** целевого таймфрейма
3. **Сохранение трассируемости** через маппинг исходных индексов
4. **Эффективность** через одно-проходную обработку
5. **Гибкость** через несколько методов агрегации для разных сценариев

Система гарантирует, что агрегированные данные корректно представляют исходную информацию на старшем таймфрейме, что критично для анализа и принятия торговых решений.

